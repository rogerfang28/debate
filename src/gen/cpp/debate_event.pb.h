// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: debate_event.proto
// Protobuf C++ Version: 5.29.5

#ifndef debate_5fevent_2eproto_2epb_2eh
#define debate_5fevent_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_debate_5fevent_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_debate_5fevent_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_debate_5fevent_2eproto;
namespace debate_event {
class AddConnection;
struct AddConnectionDefaultTypeInternal;
extern AddConnectionDefaultTypeInternal _AddConnection_default_instance_;
class ClearDebates;
struct ClearDebatesDefaultTypeInternal;
extern ClearDebatesDefaultTypeInternal _ClearDebates_default_instance_;
class CreateDebate;
struct CreateDebateDefaultTypeInternal;
extern CreateDebateDefaultTypeInternal _CreateDebate_default_instance_;
class CreateStatement;
struct CreateStatementDefaultTypeInternal;
extern CreateStatementDefaultTypeInternal _CreateStatement_default_instance_;
class DebateEvent;
struct DebateEventDefaultTypeInternal;
extern DebateEventDefaultTypeInternal _DebateEvent_default_instance_;
class DeleteDebate;
struct DeleteDebateDefaultTypeInternal;
extern DeleteDebateDefaultTypeInternal _DeleteDebate_default_instance_;
class DeleteStatement;
struct DeleteStatementDefaultTypeInternal;
extern DeleteStatementDefaultTypeInternal _DeleteStatement_default_instance_;
class EnterDebate;
struct EnterDebateDefaultTypeInternal;
extern EnterDebateDefaultTypeInternal _EnterDebate_default_instance_;
class GoHome;
struct GoHomeDefaultTypeInternal;
extern GoHomeDefaultTypeInternal _GoHome_default_instance_;
class None;
struct NoneDefaultTypeInternal;
extern NoneDefaultTypeInternal _None_default_instance_;
}  // namespace debate_event
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace debate_event {
enum EventType : int {
  EVENT_KIND_UNSPECIFIED = 0,
  NONE = 1,
  CREATE_DEBATE = 2,
  CLEAR_DEBATES = 3,
  DELETE_DEBATE = 4,
  ENTER_DEBATE = 5,
  GO_HOME = 6,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EventType_IsValid(int value);
extern const uint32_t EventType_internal_data_[];
constexpr EventType EventType_MIN = static_cast<EventType>(0);
constexpr EventType EventType_MAX = static_cast<EventType>(6);
constexpr int EventType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
EventType_descriptor();
template <typename T>
const std::string& EventType_Name(T value) {
  static_assert(std::is_same<T, EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return EventType_Name(static_cast<EventType>(value));
}
template <>
inline const std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EventType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool EventType_Parse(absl::string_view name, EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(
      EventType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class None final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.None) */ {
 public:
  inline None() : None(nullptr) {}
  ~None() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(None* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(None));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR None(
      ::google::protobuf::internal::ConstantInitialized);

  inline None(const None& from) : None(nullptr, from) {}
  inline None(None&& from) noexcept
      : None(nullptr, std::move(from)) {}
  inline None& operator=(const None& from) {
    CopyFrom(from);
    return *this;
  }
  inline None& operator=(None&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const None& default_instance() {
    return *internal_default_instance();
  }
  static inline const None* internal_default_instance() {
    return reinterpret_cast<const None*>(
        &_None_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(None& a, None& b) { a.Swap(&b); }
  inline void Swap(None* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(None* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  None* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<None>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const None& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const None& from) { None::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(None* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.None"; }

 protected:
  explicit None(::google::protobuf::Arena* arena);
  None(::google::protobuf::Arena* arena, const None& from);
  None(::google::protobuf::Arena* arena, None&& from) noexcept
      : None(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.None)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      33, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const None& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class GoHome final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.GoHome) */ {
 public:
  inline GoHome() : GoHome(nullptr) {}
  ~GoHome() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GoHome* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GoHome));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoHome(
      ::google::protobuf::internal::ConstantInitialized);

  inline GoHome(const GoHome& from) : GoHome(nullptr, from) {}
  inline GoHome(GoHome&& from) noexcept
      : GoHome(nullptr, std::move(from)) {}
  inline GoHome& operator=(const GoHome& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoHome& operator=(GoHome&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoHome& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoHome* internal_default_instance() {
    return reinterpret_cast<const GoHome*>(
        &_GoHome_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(GoHome& a, GoHome& b) { a.Swap(&b); }
  inline void Swap(GoHome* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoHome* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoHome* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GoHome>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoHome& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoHome& from) { GoHome::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GoHome* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.GoHome"; }

 protected:
  explicit GoHome(::google::protobuf::Arena* arena);
  GoHome(::google::protobuf::Arena* arena, const GoHome& from);
  GoHome(::google::protobuf::Arena* arena, GoHome&& from) noexcept
      : GoHome(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.GoHome)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GoHome& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class EnterDebate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.EnterDebate) */ {
 public:
  inline EnterDebate() : EnterDebate(nullptr) {}
  ~EnterDebate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EnterDebate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EnterDebate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EnterDebate(
      ::google::protobuf::internal::ConstantInitialized);

  inline EnterDebate(const EnterDebate& from) : EnterDebate(nullptr, from) {}
  inline EnterDebate(EnterDebate&& from) noexcept
      : EnterDebate(nullptr, std::move(from)) {}
  inline EnterDebate& operator=(const EnterDebate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterDebate& operator=(EnterDebate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterDebate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterDebate* internal_default_instance() {
    return reinterpret_cast<const EnterDebate*>(
        &_EnterDebate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(EnterDebate& a, EnterDebate& b) { a.Swap(&b); }
  inline void Swap(EnterDebate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterDebate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterDebate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EnterDebate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EnterDebate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EnterDebate& from) { EnterDebate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EnterDebate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.EnterDebate"; }

 protected:
  explicit EnterDebate(::google::protobuf::Arena* arena);
  EnterDebate(::google::protobuf::Arena* arena, const EnterDebate& from);
  EnterDebate(::google::protobuf::Arena* arena, EnterDebate&& from) noexcept
      : EnterDebate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kDebateIdFieldNumber = 2,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string debate_id = 2 [json_name = "debateId"];
  void clear_debate_id() ;
  const std::string& debate_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debate_id(Arg_&& arg, Args_... args);
  std::string* mutable_debate_id();
  PROTOBUF_NODISCARD std::string* release_debate_id();
  void set_allocated_debate_id(std::string* value);

  private:
  const std::string& _internal_debate_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debate_id(
      const std::string& value);
  std::string* _internal_mutable_debate_id();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.EnterDebate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EnterDebate& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr debate_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class DeleteStatement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.DeleteStatement) */ {
 public:
  inline DeleteStatement() : DeleteStatement(nullptr) {}
  ~DeleteStatement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteStatement* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteStatement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteStatement(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteStatement(const DeleteStatement& from) : DeleteStatement(nullptr, from) {}
  inline DeleteStatement(DeleteStatement&& from) noexcept
      : DeleteStatement(nullptr, std::move(from)) {}
  inline DeleteStatement& operator=(const DeleteStatement& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteStatement& operator=(DeleteStatement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteStatement& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteStatement* internal_default_instance() {
    return reinterpret_cast<const DeleteStatement*>(
        &_DeleteStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(DeleteStatement& a, DeleteStatement& b) { a.Swap(&b); }
  inline void Swap(DeleteStatement* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteStatement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteStatement* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteStatement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteStatement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteStatement& from) { DeleteStatement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteStatement* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.DeleteStatement"; }

 protected:
  explicit DeleteStatement(::google::protobuf::Arena* arena);
  DeleteStatement(::google::protobuf::Arena* arena, const DeleteStatement& from);
  DeleteStatement(::google::protobuf::Arena* arena, DeleteStatement&& from) noexcept
      : DeleteStatement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kDebateIdFieldNumber = 2,
    kStatementIdFieldNumber = 3,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string debate_id = 2 [json_name = "debateId"];
  void clear_debate_id() ;
  const std::string& debate_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debate_id(Arg_&& arg, Args_... args);
  std::string* mutable_debate_id();
  PROTOBUF_NODISCARD std::string* release_debate_id();
  void set_allocated_debate_id(std::string* value);

  private:
  const std::string& _internal_debate_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debate_id(
      const std::string& value);
  std::string* _internal_mutable_debate_id();

  public:
  // string statement_id = 3 [json_name = "statementId"];
  void clear_statement_id() ;
  const std::string& statement_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_statement_id(Arg_&& arg, Args_... args);
  std::string* mutable_statement_id();
  PROTOBUF_NODISCARD std::string* release_statement_id();
  void set_allocated_statement_id(std::string* value);

  private:
  const std::string& _internal_statement_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statement_id(
      const std::string& value);
  std::string* _internal_mutable_statement_id();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.DeleteStatement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteStatement& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr debate_id_;
    ::google::protobuf::internal::ArenaStringPtr statement_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class DeleteDebate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.DeleteDebate) */ {
 public:
  inline DeleteDebate() : DeleteDebate(nullptr) {}
  ~DeleteDebate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteDebate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteDebate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteDebate(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteDebate(const DeleteDebate& from) : DeleteDebate(nullptr, from) {}
  inline DeleteDebate(DeleteDebate&& from) noexcept
      : DeleteDebate(nullptr, std::move(from)) {}
  inline DeleteDebate& operator=(const DeleteDebate& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDebate& operator=(DeleteDebate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDebate& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDebate* internal_default_instance() {
    return reinterpret_cast<const DeleteDebate*>(
        &_DeleteDebate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(DeleteDebate& a, DeleteDebate& b) { a.Swap(&b); }
  inline void Swap(DeleteDebate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDebate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDebate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteDebate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteDebate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteDebate& from) { DeleteDebate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteDebate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.DeleteDebate"; }

 protected:
  explicit DeleteDebate(::google::protobuf::Arena* arena);
  DeleteDebate(::google::protobuf::Arena* arena, const DeleteDebate& from);
  DeleteDebate(::google::protobuf::Arena* arena, DeleteDebate&& from) noexcept
      : DeleteDebate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kDebateIdFieldNumber = 2,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string debate_id = 2 [json_name = "debateId"];
  void clear_debate_id() ;
  const std::string& debate_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debate_id(Arg_&& arg, Args_... args);
  std::string* mutable_debate_id();
  PROTOBUF_NODISCARD std::string* release_debate_id();
  void set_allocated_debate_id(std::string* value);

  private:
  const std::string& _internal_debate_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debate_id(
      const std::string& value);
  std::string* _internal_mutable_debate_id();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.DeleteDebate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteDebate& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr debate_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class CreateStatement final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.CreateStatement) */ {
 public:
  inline CreateStatement() : CreateStatement(nullptr) {}
  ~CreateStatement() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateStatement* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateStatement));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateStatement(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateStatement(const CreateStatement& from) : CreateStatement(nullptr, from) {}
  inline CreateStatement(CreateStatement&& from) noexcept
      : CreateStatement(nullptr, std::move(from)) {}
  inline CreateStatement& operator=(const CreateStatement& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateStatement& operator=(CreateStatement&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateStatement& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateStatement* internal_default_instance() {
    return reinterpret_cast<const CreateStatement*>(
        &_CreateStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(CreateStatement& a, CreateStatement& b) { a.Swap(&b); }
  inline void Swap(CreateStatement* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateStatement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateStatement* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateStatement>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateStatement& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateStatement& from) { CreateStatement::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateStatement* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.CreateStatement"; }

 protected:
  explicit CreateStatement(::google::protobuf::Arena* arena);
  CreateStatement(::google::protobuf::Arena* arena, const CreateStatement& from);
  CreateStatement(::google::protobuf::Arena* arena, CreateStatement&& from) noexcept
      : CreateStatement(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kDebateIdFieldNumber = 2,
    kStatementFieldNumber = 3,
    kParentIdFieldNumber = 4,
    kConnectionFieldNumber = 5,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string debate_id = 2 [json_name = "debateId"];
  void clear_debate_id() ;
  const std::string& debate_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debate_id(Arg_&& arg, Args_... args);
  std::string* mutable_debate_id();
  PROTOBUF_NODISCARD std::string* release_debate_id();
  void set_allocated_debate_id(std::string* value);

  private:
  const std::string& _internal_debate_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debate_id(
      const std::string& value);
  std::string* _internal_mutable_debate_id();

  public:
  // string statement = 3 [json_name = "statement"];
  void clear_statement() ;
  const std::string& statement() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_statement(Arg_&& arg, Args_... args);
  std::string* mutable_statement();
  PROTOBUF_NODISCARD std::string* release_statement();
  void set_allocated_statement(std::string* value);

  private:
  const std::string& _internal_statement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_statement(
      const std::string& value);
  std::string* _internal_mutable_statement();

  public:
  // string parent_id = 4 [json_name = "parentId"];
  void clear_parent_id() ;
  const std::string& parent_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent_id(Arg_&& arg, Args_... args);
  std::string* mutable_parent_id();
  PROTOBUF_NODISCARD std::string* release_parent_id();
  void set_allocated_parent_id(std::string* value);

  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(
      const std::string& value);
  std::string* _internal_mutable_parent_id();

  public:
  // string connection = 5 [json_name = "connection"];
  void clear_connection() ;
  const std::string& connection() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connection(Arg_&& arg, Args_... args);
  std::string* mutable_connection();
  PROTOBUF_NODISCARD std::string* release_connection();
  void set_allocated_connection(std::string* value);

  private:
  const std::string& _internal_connection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection(
      const std::string& value);
  std::string* _internal_mutable_connection();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.CreateStatement)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      81, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateStatement& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr debate_id_;
    ::google::protobuf::internal::ArenaStringPtr statement_;
    ::google::protobuf::internal::ArenaStringPtr parent_id_;
    ::google::protobuf::internal::ArenaStringPtr connection_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class CreateDebate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.CreateDebate) */ {
 public:
  inline CreateDebate() : CreateDebate(nullptr) {}
  ~CreateDebate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateDebate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateDebate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateDebate(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateDebate(const CreateDebate& from) : CreateDebate(nullptr, from) {}
  inline CreateDebate(CreateDebate&& from) noexcept
      : CreateDebate(nullptr, std::move(from)) {}
  inline CreateDebate& operator=(const CreateDebate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDebate& operator=(CreateDebate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDebate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDebate* internal_default_instance() {
    return reinterpret_cast<const CreateDebate*>(
        &_CreateDebate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CreateDebate& a, CreateDebate& b) { a.Swap(&b); }
  inline void Swap(CreateDebate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDebate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDebate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateDebate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateDebate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateDebate& from) { CreateDebate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateDebate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.CreateDebate"; }

 protected:
  explicit CreateDebate(::google::protobuf::Arena* arena);
  CreateDebate(::google::protobuf::Arena* arena, const CreateDebate& from);
  CreateDebate(::google::protobuf::Arena* arena, CreateDebate&& from) noexcept
      : CreateDebate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kDebateTopicFieldNumber = 2,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string debate_topic = 2 [json_name = "debateTopic"];
  void clear_debate_topic() ;
  const std::string& debate_topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debate_topic(Arg_&& arg, Args_... args);
  std::string* mutable_debate_topic();
  PROTOBUF_NODISCARD std::string* release_debate_topic();
  void set_allocated_debate_topic(std::string* value);

  private:
  const std::string& _internal_debate_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debate_topic(
      const std::string& value);
  std::string* _internal_mutable_debate_topic();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.CreateDebate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      53, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateDebate& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr debate_topic_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class ClearDebates final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.ClearDebates) */ {
 public:
  inline ClearDebates() : ClearDebates(nullptr) {}
  ~ClearDebates() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ClearDebates* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ClearDebates));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClearDebates(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClearDebates(const ClearDebates& from) : ClearDebates(nullptr, from) {}
  inline ClearDebates(ClearDebates&& from) noexcept
      : ClearDebates(nullptr, std::move(from)) {}
  inline ClearDebates& operator=(const ClearDebates& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearDebates& operator=(ClearDebates&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClearDebates& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearDebates* internal_default_instance() {
    return reinterpret_cast<const ClearDebates*>(
        &_ClearDebates_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ClearDebates& a, ClearDebates& b) { a.Swap(&b); }
  inline void Swap(ClearDebates* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearDebates* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearDebates* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ClearDebates>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ClearDebates& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ClearDebates& from) { ClearDebates::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ClearDebates* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.ClearDebates"; }

 protected:
  explicit ClearDebates(::google::protobuf::Arena* arena);
  ClearDebates(::google::protobuf::Arena* arena, const ClearDebates& from);
  ClearDebates(::google::protobuf::Arena* arena, ClearDebates&& from) noexcept
      : ClearDebates(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.ClearDebates)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ClearDebates& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class AddConnection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.AddConnection) */ {
 public:
  inline AddConnection() : AddConnection(nullptr) {}
  ~AddConnection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddConnection* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddConnection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddConnection(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddConnection(const AddConnection& from) : AddConnection(nullptr, from) {}
  inline AddConnection(AddConnection&& from) noexcept
      : AddConnection(nullptr, std::move(from)) {}
  inline AddConnection& operator=(const AddConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddConnection& operator=(AddConnection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddConnection* internal_default_instance() {
    return reinterpret_cast<const AddConnection*>(
        &_AddConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AddConnection& a, AddConnection& b) { a.Swap(&b); }
  inline void Swap(AddConnection* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddConnection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddConnection* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddConnection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddConnection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddConnection& from) { AddConnection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddConnection* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.AddConnection"; }

 protected:
  explicit AddConnection(::google::protobuf::Arena* arena);
  AddConnection(::google::protobuf::Arena* arena, const AddConnection& from);
  AddConnection(::google::protobuf::Arena* arena, AddConnection&& from) noexcept
      : AddConnection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kDebateIdFieldNumber = 2,
    kFromIdFieldNumber = 3,
    kToIdFieldNumber = 4,
    kConnectionFieldNumber = 5,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string debate_id = 2 [json_name = "debateId"];
  void clear_debate_id() ;
  const std::string& debate_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debate_id(Arg_&& arg, Args_... args);
  std::string* mutable_debate_id();
  PROTOBUF_NODISCARD std::string* release_debate_id();
  void set_allocated_debate_id(std::string* value);

  private:
  const std::string& _internal_debate_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debate_id(
      const std::string& value);
  std::string* _internal_mutable_debate_id();

  public:
  // string from_id = 3 [json_name = "fromId"];
  void clear_from_id() ;
  const std::string& from_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from_id(Arg_&& arg, Args_... args);
  std::string* mutable_from_id();
  PROTOBUF_NODISCARD std::string* release_from_id();
  void set_allocated_from_id(std::string* value);

  private:
  const std::string& _internal_from_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_id(
      const std::string& value);
  std::string* _internal_mutable_from_id();

  public:
  // string to_id = 4 [json_name = "toId"];
  void clear_to_id() ;
  const std::string& to_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_to_id(Arg_&& arg, Args_... args);
  std::string* mutable_to_id();
  PROTOBUF_NODISCARD std::string* release_to_id();
  void set_allocated_to_id(std::string* value);

  private:
  const std::string& _internal_to_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_id(
      const std::string& value);
  std::string* _internal_mutable_to_id();

  public:
  // string connection = 5 [json_name = "connection"];
  void clear_connection() ;
  const std::string& connection() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connection(Arg_&& arg, Args_... args);
  std::string* mutable_connection();
  PROTOBUF_NODISCARD std::string* release_connection();
  void set_allocated_connection(std::string* value);

  private:
  const std::string& _internal_connection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection(
      const std::string& value);
  std::string* _internal_mutable_connection();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.AddConnection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      73, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AddConnection& from_msg);
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr debate_id_;
    ::google::protobuf::internal::ArenaStringPtr from_id_;
    ::google::protobuf::internal::ArenaStringPtr to_id_;
    ::google::protobuf::internal::ArenaStringPtr connection_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class DebateEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.DebateEvent) */ {
 public:
  inline DebateEvent() : DebateEvent(nullptr) {}
  ~DebateEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DebateEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DebateEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DebateEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline DebateEvent(const DebateEvent& from) : DebateEvent(nullptr, from) {}
  inline DebateEvent(DebateEvent&& from) noexcept
      : DebateEvent(nullptr, std::move(from)) {}
  inline DebateEvent& operator=(const DebateEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebateEvent& operator=(DebateEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebateEvent& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kCreateDebate = 10,
    kClearDebates = 11,
    kDeleteDebate = 12,
    kEnterDebate = 13,
    kGoHome = 14,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const DebateEvent* internal_default_instance() {
    return reinterpret_cast<const DebateEvent*>(
        &_DebateEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(DebateEvent& a, DebateEvent& b) { a.Swap(&b); }
  inline void Swap(DebateEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebateEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebateEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DebateEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DebateEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DebateEvent& from) { DebateEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DebateEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.DebateEvent"; }

 protected:
  explicit DebateEvent(::google::protobuf::Arena* arena);
  DebateEvent(::google::protobuf::Arena* arena, const DebateEvent& from);
  DebateEvent(::google::protobuf::Arena* arena, DebateEvent&& from) noexcept
      : DebateEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 1,
    kIdFieldNumber = 2,
    kOccurredAtFieldNumber = 3,
    kTypeFieldNumber = 4,
    kCreateDebateFieldNumber = 10,
    kClearDebatesFieldNumber = 11,
    kDeleteDebateFieldNumber = 12,
    kEnterDebateFieldNumber = 13,
    kGoHomeFieldNumber = 14,
  };
  // string user_id = 1 [json_name = "userId"];
  void clear_user_id() ;
  const std::string& user_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_id(Arg_&& arg, Args_... args);
  std::string* mutable_user_id();
  PROTOBUF_NODISCARD std::string* release_user_id();
  void set_allocated_user_id(std::string* value);

  private:
  const std::string& _internal_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_id(
      const std::string& value);
  std::string* _internal_mutable_user_id();

  public:
  // string id = 2 [json_name = "id"];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .google.protobuf.Timestamp occurred_at = 3 [json_name = "occurredAt"];
  bool has_occurred_at() const;
  void clear_occurred_at() ;
  const ::google::protobuf::Timestamp& occurred_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_occurred_at();
  ::google::protobuf::Timestamp* mutable_occurred_at();
  void set_allocated_occurred_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_occurred_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_occurred_at();

  private:
  const ::google::protobuf::Timestamp& _internal_occurred_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_occurred_at();

  public:
  // .debate_event.EventType type = 4 [json_name = "type"];
  void clear_type() ;
  ::debate_event::EventType type() const;
  void set_type(::debate_event::EventType value);

  private:
  ::debate_event::EventType _internal_type() const;
  void _internal_set_type(::debate_event::EventType value);

  public:
  // .debate_event.CreateDebate create_debate = 10 [json_name = "createDebate"];
  bool has_create_debate() const;
  private:
  bool _internal_has_create_debate() const;

  public:
  void clear_create_debate() ;
  const ::debate_event::CreateDebate& create_debate() const;
  PROTOBUF_NODISCARD ::debate_event::CreateDebate* release_create_debate();
  ::debate_event::CreateDebate* mutable_create_debate();
  void set_allocated_create_debate(::debate_event::CreateDebate* value);
  void unsafe_arena_set_allocated_create_debate(::debate_event::CreateDebate* value);
  ::debate_event::CreateDebate* unsafe_arena_release_create_debate();

  private:
  const ::debate_event::CreateDebate& _internal_create_debate() const;
  ::debate_event::CreateDebate* _internal_mutable_create_debate();

  public:
  // .debate_event.ClearDebates clear_debates = 11 [json_name = "clearDebates"];
  bool has_clear_debates() const;
  private:
  bool _internal_has_clear_debates() const;

  public:
  void clear_clear_debates() ;
  const ::debate_event::ClearDebates& clear_debates() const;
  PROTOBUF_NODISCARD ::debate_event::ClearDebates* release_clear_debates();
  ::debate_event::ClearDebates* mutable_clear_debates();
  void set_allocated_clear_debates(::debate_event::ClearDebates* value);
  void unsafe_arena_set_allocated_clear_debates(::debate_event::ClearDebates* value);
  ::debate_event::ClearDebates* unsafe_arena_release_clear_debates();

  private:
  const ::debate_event::ClearDebates& _internal_clear_debates() const;
  ::debate_event::ClearDebates* _internal_mutable_clear_debates();

  public:
  // .debate_event.DeleteDebate delete_debate = 12 [json_name = "deleteDebate"];
  bool has_delete_debate() const;
  private:
  bool _internal_has_delete_debate() const;

  public:
  void clear_delete_debate() ;
  const ::debate_event::DeleteDebate& delete_debate() const;
  PROTOBUF_NODISCARD ::debate_event::DeleteDebate* release_delete_debate();
  ::debate_event::DeleteDebate* mutable_delete_debate();
  void set_allocated_delete_debate(::debate_event::DeleteDebate* value);
  void unsafe_arena_set_allocated_delete_debate(::debate_event::DeleteDebate* value);
  ::debate_event::DeleteDebate* unsafe_arena_release_delete_debate();

  private:
  const ::debate_event::DeleteDebate& _internal_delete_debate() const;
  ::debate_event::DeleteDebate* _internal_mutable_delete_debate();

  public:
  // .debate_event.EnterDebate enter_debate = 13 [json_name = "enterDebate"];
  bool has_enter_debate() const;
  private:
  bool _internal_has_enter_debate() const;

  public:
  void clear_enter_debate() ;
  const ::debate_event::EnterDebate& enter_debate() const;
  PROTOBUF_NODISCARD ::debate_event::EnterDebate* release_enter_debate();
  ::debate_event::EnterDebate* mutable_enter_debate();
  void set_allocated_enter_debate(::debate_event::EnterDebate* value);
  void unsafe_arena_set_allocated_enter_debate(::debate_event::EnterDebate* value);
  ::debate_event::EnterDebate* unsafe_arena_release_enter_debate();

  private:
  const ::debate_event::EnterDebate& _internal_enter_debate() const;
  ::debate_event::EnterDebate* _internal_mutable_enter_debate();

  public:
  // .debate_event.GoHome go_home = 14 [json_name = "goHome"];
  bool has_go_home() const;
  private:
  bool _internal_has_go_home() const;

  public:
  void clear_go_home() ;
  const ::debate_event::GoHome& go_home() const;
  PROTOBUF_NODISCARD ::debate_event::GoHome* release_go_home();
  ::debate_event::GoHome* mutable_go_home();
  void set_allocated_go_home(::debate_event::GoHome* value);
  void unsafe_arena_set_allocated_go_home(::debate_event::GoHome* value);
  ::debate_event::GoHome* unsafe_arena_release_go_home();

  private:
  const ::debate_event::GoHome& _internal_go_home() const;
  ::debate_event::GoHome* _internal_mutable_go_home();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:debate_event.DebateEvent)
 private:
  class _Internal;
  void set_has_create_debate();
  void set_has_clear_debates();
  void set_has_delete_debate();
  void set_has_enter_debate();
  void set_has_go_home();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 9, 6,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DebateEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr user_id_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::Timestamp* occurred_at_;
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::debate_event::CreateDebate* create_debate_;
      ::debate_event::ClearDebates* clear_debates_;
      ::debate_event::DeleteDebate* delete_debate_;
      ::debate_event::EnterDebate* enter_debate_;
      ::debate_event::GoHome* go_home_;
    } payload_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// None

// string user_id = 1 [json_name = "userId"];
inline void None::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& None::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.None.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void None::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.None.user_id)
}
inline std::string* None::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.None.user_id)
  return _s;
}
inline const std::string& None::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void None::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* None::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* None::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.None.user_id)
  return _impl_.user_id_.Release();
}
inline void None::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.None.user_id)
}

// -------------------------------------------------------------------

// CreateDebate

// string user_id = 1 [json_name = "userId"];
inline void CreateDebate::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& CreateDebate::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.CreateDebate.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateDebate::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.CreateDebate.user_id)
}
inline std::string* CreateDebate::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.CreateDebate.user_id)
  return _s;
}
inline const std::string& CreateDebate::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void CreateDebate::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* CreateDebate::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* CreateDebate::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.CreateDebate.user_id)
  return _impl_.user_id_.Release();
}
inline void CreateDebate::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.CreateDebate.user_id)
}

// string debate_topic = 2 [json_name = "debateTopic"];
inline void CreateDebate::clear_debate_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_topic_.ClearToEmpty();
}
inline const std::string& CreateDebate::debate_topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.CreateDebate.debate_topic)
  return _internal_debate_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateDebate::set_debate_topic(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.CreateDebate.debate_topic)
}
inline std::string* CreateDebate::mutable_debate_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_debate_topic();
  // @@protoc_insertion_point(field_mutable:debate_event.CreateDebate.debate_topic)
  return _s;
}
inline const std::string& CreateDebate::_internal_debate_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_topic_.Get();
}
inline void CreateDebate::_internal_set_debate_topic(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_topic_.Set(value, GetArena());
}
inline std::string* CreateDebate::_internal_mutable_debate_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.debate_topic_.Mutable( GetArena());
}
inline std::string* CreateDebate::release_debate_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.CreateDebate.debate_topic)
  return _impl_.debate_topic_.Release();
}
inline void CreateDebate::set_allocated_debate_topic(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_topic_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.debate_topic_.IsDefault()) {
    _impl_.debate_topic_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.CreateDebate.debate_topic)
}

// -------------------------------------------------------------------

// ClearDebates

// string user_id = 1 [json_name = "userId"];
inline void ClearDebates::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& ClearDebates::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.ClearDebates.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClearDebates::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.ClearDebates.user_id)
}
inline std::string* ClearDebates::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.ClearDebates.user_id)
  return _s;
}
inline const std::string& ClearDebates::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void ClearDebates::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* ClearDebates::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* ClearDebates::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.ClearDebates.user_id)
  return _impl_.user_id_.Release();
}
inline void ClearDebates::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.ClearDebates.user_id)
}

// -------------------------------------------------------------------

// DeleteDebate

// string user_id = 1 [json_name = "userId"];
inline void DeleteDebate::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& DeleteDebate::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DeleteDebate.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteDebate::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.DeleteDebate.user_id)
}
inline std::string* DeleteDebate::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.DeleteDebate.user_id)
  return _s;
}
inline const std::string& DeleteDebate::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void DeleteDebate::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* DeleteDebate::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* DeleteDebate::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DeleteDebate.user_id)
  return _impl_.user_id_.Release();
}
inline void DeleteDebate::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.DeleteDebate.user_id)
}

// string debate_id = 2 [json_name = "debateId"];
inline void DeleteDebate::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.ClearToEmpty();
}
inline const std::string& DeleteDebate::debate_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DeleteDebate.debate_id)
  return _internal_debate_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteDebate::set_debate_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.DeleteDebate.debate_id)
}
inline std::string* DeleteDebate::mutable_debate_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_debate_id();
  // @@protoc_insertion_point(field_mutable:debate_event.DeleteDebate.debate_id)
  return _s;
}
inline const std::string& DeleteDebate::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_.Get();
}
inline void DeleteDebate::_internal_set_debate_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(value, GetArena());
}
inline std::string* DeleteDebate::_internal_mutable_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.debate_id_.Mutable( GetArena());
}
inline std::string* DeleteDebate::release_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DeleteDebate.debate_id)
  return _impl_.debate_id_.Release();
}
inline void DeleteDebate::set_allocated_debate_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.debate_id_.IsDefault()) {
    _impl_.debate_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.DeleteDebate.debate_id)
}

// -------------------------------------------------------------------

// EnterDebate

// string user_id = 1 [json_name = "userId"];
inline void EnterDebate::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& EnterDebate::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.EnterDebate.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EnterDebate::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.EnterDebate.user_id)
}
inline std::string* EnterDebate::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.EnterDebate.user_id)
  return _s;
}
inline const std::string& EnterDebate::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void EnterDebate::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* EnterDebate::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* EnterDebate::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.EnterDebate.user_id)
  return _impl_.user_id_.Release();
}
inline void EnterDebate::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.EnterDebate.user_id)
}

// string debate_id = 2 [json_name = "debateId"];
inline void EnterDebate::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.ClearToEmpty();
}
inline const std::string& EnterDebate::debate_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.EnterDebate.debate_id)
  return _internal_debate_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EnterDebate::set_debate_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.EnterDebate.debate_id)
}
inline std::string* EnterDebate::mutable_debate_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_debate_id();
  // @@protoc_insertion_point(field_mutable:debate_event.EnterDebate.debate_id)
  return _s;
}
inline const std::string& EnterDebate::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_.Get();
}
inline void EnterDebate::_internal_set_debate_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(value, GetArena());
}
inline std::string* EnterDebate::_internal_mutable_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.debate_id_.Mutable( GetArena());
}
inline std::string* EnterDebate::release_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.EnterDebate.debate_id)
  return _impl_.debate_id_.Release();
}
inline void EnterDebate::set_allocated_debate_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.debate_id_.IsDefault()) {
    _impl_.debate_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.EnterDebate.debate_id)
}

// -------------------------------------------------------------------

// GoHome

// string user_id = 1 [json_name = "userId"];
inline void GoHome::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& GoHome::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.GoHome.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GoHome::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.GoHome.user_id)
}
inline std::string* GoHome::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.GoHome.user_id)
  return _s;
}
inline const std::string& GoHome::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void GoHome::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* GoHome::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* GoHome::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.GoHome.user_id)
  return _impl_.user_id_.Release();
}
inline void GoHome::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.GoHome.user_id)
}

// -------------------------------------------------------------------

// CreateStatement

// string user_id = 1 [json_name = "userId"];
inline void CreateStatement::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& CreateStatement::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.CreateStatement.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateStatement::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.CreateStatement.user_id)
}
inline std::string* CreateStatement::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.CreateStatement.user_id)
  return _s;
}
inline const std::string& CreateStatement::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void CreateStatement::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* CreateStatement::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* CreateStatement::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.CreateStatement.user_id)
  return _impl_.user_id_.Release();
}
inline void CreateStatement::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.CreateStatement.user_id)
}

// string debate_id = 2 [json_name = "debateId"];
inline void CreateStatement::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.ClearToEmpty();
}
inline const std::string& CreateStatement::debate_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.CreateStatement.debate_id)
  return _internal_debate_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateStatement::set_debate_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.CreateStatement.debate_id)
}
inline std::string* CreateStatement::mutable_debate_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_debate_id();
  // @@protoc_insertion_point(field_mutable:debate_event.CreateStatement.debate_id)
  return _s;
}
inline const std::string& CreateStatement::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_.Get();
}
inline void CreateStatement::_internal_set_debate_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(value, GetArena());
}
inline std::string* CreateStatement::_internal_mutable_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.debate_id_.Mutable( GetArena());
}
inline std::string* CreateStatement::release_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.CreateStatement.debate_id)
  return _impl_.debate_id_.Release();
}
inline void CreateStatement::set_allocated_debate_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.debate_id_.IsDefault()) {
    _impl_.debate_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.CreateStatement.debate_id)
}

// string statement = 3 [json_name = "statement"];
inline void CreateStatement::clear_statement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_.ClearToEmpty();
}
inline const std::string& CreateStatement::statement() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.CreateStatement.statement)
  return _internal_statement();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateStatement::set_statement(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.CreateStatement.statement)
}
inline std::string* CreateStatement::mutable_statement() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_statement();
  // @@protoc_insertion_point(field_mutable:debate_event.CreateStatement.statement)
  return _s;
}
inline const std::string& CreateStatement::_internal_statement() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.statement_.Get();
}
inline void CreateStatement::_internal_set_statement(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_.Set(value, GetArena());
}
inline std::string* CreateStatement::_internal_mutable_statement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.statement_.Mutable( GetArena());
}
inline std::string* CreateStatement::release_statement() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.CreateStatement.statement)
  return _impl_.statement_.Release();
}
inline void CreateStatement::set_allocated_statement(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.statement_.IsDefault()) {
    _impl_.statement_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.CreateStatement.statement)
}

// string parent_id = 4 [json_name = "parentId"];
inline void CreateStatement::clear_parent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_.ClearToEmpty();
}
inline const std::string& CreateStatement::parent_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.CreateStatement.parent_id)
  return _internal_parent_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateStatement::set_parent_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.CreateStatement.parent_id)
}
inline std::string* CreateStatement::mutable_parent_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:debate_event.CreateStatement.parent_id)
  return _s;
}
inline const std::string& CreateStatement::_internal_parent_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_id_.Get();
}
inline void CreateStatement::_internal_set_parent_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_.Set(value, GetArena());
}
inline std::string* CreateStatement::_internal_mutable_parent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_id_.Mutable( GetArena());
}
inline std::string* CreateStatement::release_parent_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.CreateStatement.parent_id)
  return _impl_.parent_id_.Release();
}
inline void CreateStatement::set_allocated_parent_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_id_.IsDefault()) {
    _impl_.parent_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.CreateStatement.parent_id)
}

// string connection = 5 [json_name = "connection"];
inline void CreateStatement::clear_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.ClearToEmpty();
}
inline const std::string& CreateStatement::connection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.CreateStatement.connection)
  return _internal_connection();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateStatement::set_connection(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.CreateStatement.connection)
}
inline std::string* CreateStatement::mutable_connection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connection();
  // @@protoc_insertion_point(field_mutable:debate_event.CreateStatement.connection)
  return _s;
}
inline const std::string& CreateStatement::_internal_connection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_.Get();
}
inline void CreateStatement::_internal_set_connection(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.Set(value, GetArena());
}
inline std::string* CreateStatement::_internal_mutable_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connection_.Mutable( GetArena());
}
inline std::string* CreateStatement::release_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.CreateStatement.connection)
  return _impl_.connection_.Release();
}
inline void CreateStatement::set_allocated_connection(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connection_.IsDefault()) {
    _impl_.connection_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.CreateStatement.connection)
}

// -------------------------------------------------------------------

// DeleteStatement

// string user_id = 1 [json_name = "userId"];
inline void DeleteStatement::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& DeleteStatement::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DeleteStatement.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteStatement::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.DeleteStatement.user_id)
}
inline std::string* DeleteStatement::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.DeleteStatement.user_id)
  return _s;
}
inline const std::string& DeleteStatement::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void DeleteStatement::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* DeleteStatement::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* DeleteStatement::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DeleteStatement.user_id)
  return _impl_.user_id_.Release();
}
inline void DeleteStatement::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.DeleteStatement.user_id)
}

// string debate_id = 2 [json_name = "debateId"];
inline void DeleteStatement::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.ClearToEmpty();
}
inline const std::string& DeleteStatement::debate_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DeleteStatement.debate_id)
  return _internal_debate_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteStatement::set_debate_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.DeleteStatement.debate_id)
}
inline std::string* DeleteStatement::mutable_debate_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_debate_id();
  // @@protoc_insertion_point(field_mutable:debate_event.DeleteStatement.debate_id)
  return _s;
}
inline const std::string& DeleteStatement::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_.Get();
}
inline void DeleteStatement::_internal_set_debate_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(value, GetArena());
}
inline std::string* DeleteStatement::_internal_mutable_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.debate_id_.Mutable( GetArena());
}
inline std::string* DeleteStatement::release_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DeleteStatement.debate_id)
  return _impl_.debate_id_.Release();
}
inline void DeleteStatement::set_allocated_debate_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.debate_id_.IsDefault()) {
    _impl_.debate_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.DeleteStatement.debate_id)
}

// string statement_id = 3 [json_name = "statementId"];
inline void DeleteStatement::clear_statement_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_id_.ClearToEmpty();
}
inline const std::string& DeleteStatement::statement_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DeleteStatement.statement_id)
  return _internal_statement_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteStatement::set_statement_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.DeleteStatement.statement_id)
}
inline std::string* DeleteStatement::mutable_statement_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_statement_id();
  // @@protoc_insertion_point(field_mutable:debate_event.DeleteStatement.statement_id)
  return _s;
}
inline const std::string& DeleteStatement::_internal_statement_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.statement_id_.Get();
}
inline void DeleteStatement::_internal_set_statement_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_id_.Set(value, GetArena());
}
inline std::string* DeleteStatement::_internal_mutable_statement_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.statement_id_.Mutable( GetArena());
}
inline std::string* DeleteStatement::release_statement_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DeleteStatement.statement_id)
  return _impl_.statement_id_.Release();
}
inline void DeleteStatement::set_allocated_statement_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.statement_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.statement_id_.IsDefault()) {
    _impl_.statement_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.DeleteStatement.statement_id)
}

// -------------------------------------------------------------------

// AddConnection

// string user_id = 1 [json_name = "userId"];
inline void AddConnection::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& AddConnection::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddConnection::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.user_id)
}
inline std::string* AddConnection::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.AddConnection.user_id)
  return _s;
}
inline const std::string& AddConnection::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void AddConnection::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* AddConnection::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* AddConnection::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.AddConnection.user_id)
  return _impl_.user_id_.Release();
}
inline void AddConnection::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.AddConnection.user_id)
}

// string debate_id = 2 [json_name = "debateId"];
inline void AddConnection::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.ClearToEmpty();
}
inline const std::string& AddConnection::debate_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.debate_id)
  return _internal_debate_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddConnection::set_debate_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.debate_id)
}
inline std::string* AddConnection::mutable_debate_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_debate_id();
  // @@protoc_insertion_point(field_mutable:debate_event.AddConnection.debate_id)
  return _s;
}
inline const std::string& AddConnection::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_.Get();
}
inline void AddConnection::_internal_set_debate_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.Set(value, GetArena());
}
inline std::string* AddConnection::_internal_mutable_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.debate_id_.Mutable( GetArena());
}
inline std::string* AddConnection::release_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.AddConnection.debate_id)
  return _impl_.debate_id_.Release();
}
inline void AddConnection::set_allocated_debate_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.debate_id_.IsDefault()) {
    _impl_.debate_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.AddConnection.debate_id)
}

// string from_id = 3 [json_name = "fromId"];
inline void AddConnection::clear_from_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_id_.ClearToEmpty();
}
inline const std::string& AddConnection::from_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.from_id)
  return _internal_from_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddConnection::set_from_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.from_id)
}
inline std::string* AddConnection::mutable_from_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_from_id();
  // @@protoc_insertion_point(field_mutable:debate_event.AddConnection.from_id)
  return _s;
}
inline const std::string& AddConnection::_internal_from_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_id_.Get();
}
inline void AddConnection::_internal_set_from_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_id_.Set(value, GetArena());
}
inline std::string* AddConnection::_internal_mutable_from_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.from_id_.Mutable( GetArena());
}
inline std::string* AddConnection::release_from_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.AddConnection.from_id)
  return _impl_.from_id_.Release();
}
inline void AddConnection::set_allocated_from_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.from_id_.IsDefault()) {
    _impl_.from_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.AddConnection.from_id)
}

// string to_id = 4 [json_name = "toId"];
inline void AddConnection::clear_to_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_id_.ClearToEmpty();
}
inline const std::string& AddConnection::to_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.to_id)
  return _internal_to_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddConnection::set_to_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.to_id)
}
inline std::string* AddConnection::mutable_to_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_to_id();
  // @@protoc_insertion_point(field_mutable:debate_event.AddConnection.to_id)
  return _s;
}
inline const std::string& AddConnection::_internal_to_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_id_.Get();
}
inline void AddConnection::_internal_set_to_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_id_.Set(value, GetArena());
}
inline std::string* AddConnection::_internal_mutable_to_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.to_id_.Mutable( GetArena());
}
inline std::string* AddConnection::release_to_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.AddConnection.to_id)
  return _impl_.to_id_.Release();
}
inline void AddConnection::set_allocated_to_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.to_id_.IsDefault()) {
    _impl_.to_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.AddConnection.to_id)
}

// string connection = 5 [json_name = "connection"];
inline void AddConnection::clear_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.ClearToEmpty();
}
inline const std::string& AddConnection::connection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.connection)
  return _internal_connection();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddConnection::set_connection(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.connection)
}
inline std::string* AddConnection::mutable_connection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connection();
  // @@protoc_insertion_point(field_mutable:debate_event.AddConnection.connection)
  return _s;
}
inline const std::string& AddConnection::_internal_connection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_.Get();
}
inline void AddConnection::_internal_set_connection(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.Set(value, GetArena());
}
inline std::string* AddConnection::_internal_mutable_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connection_.Mutable( GetArena());
}
inline std::string* AddConnection::release_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.AddConnection.connection)
  return _impl_.connection_.Release();
}
inline void AddConnection::set_allocated_connection(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connection_.IsDefault()) {
    _impl_.connection_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.AddConnection.connection)
}

// -------------------------------------------------------------------

// DebateEvent

// string user_id = 1 [json_name = "userId"];
inline void DebateEvent::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.ClearToEmpty();
}
inline const std::string& DebateEvent::user_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.user_id)
  return _internal_user_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebateEvent::set_user_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.DebateEvent.user_id)
}
inline std::string* DebateEvent::mutable_user_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_id();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.user_id)
  return _s;
}
inline const std::string& DebateEvent::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_.Get();
}
inline void DebateEvent::_internal_set_user_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.Set(value, GetArena());
}
inline std::string* DebateEvent::_internal_mutable_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.user_id_.Mutable( GetArena());
}
inline std::string* DebateEvent::release_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.user_id)
  return _impl_.user_id_.Release();
}
inline void DebateEvent::set_allocated_user_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.user_id_.IsDefault()) {
    _impl_.user_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.DebateEvent.user_id)
}

// string id = 2 [json_name = "id"];
inline void DebateEvent::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DebateEvent::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DebateEvent::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.DebateEvent.id)
}
inline std::string* DebateEvent::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.id)
  return _s;
}
inline const std::string& DebateEvent::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void DebateEvent::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DebateEvent::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DebateEvent::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.id)
  return _impl_.id_.Release();
}
inline void DebateEvent::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.DebateEvent.id)
}

// .google.protobuf.Timestamp occurred_at = 3 [json_name = "occurredAt"];
inline bool DebateEvent::has_occurred_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.occurred_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& DebateEvent::_internal_occurred_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.occurred_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& DebateEvent::occurred_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.occurred_at)
  return _internal_occurred_at();
}
inline void DebateEvent::unsafe_arena_set_allocated_occurred_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.occurred_at_);
  }
  _impl_.occurred_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.occurred_at)
}
inline ::google::protobuf::Timestamp* DebateEvent::release_occurred_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.occurred_at_;
  _impl_.occurred_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* DebateEvent::unsafe_arena_release_occurred_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.occurred_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.occurred_at_;
  _impl_.occurred_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* DebateEvent::_internal_mutable_occurred_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.occurred_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.occurred_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.occurred_at_;
}
inline ::google::protobuf::Timestamp* DebateEvent::mutable_occurred_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_occurred_at();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.occurred_at)
  return _msg;
}
inline void DebateEvent::set_allocated_occurred_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.occurred_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.occurred_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:debate_event.DebateEvent.occurred_at)
}

// .debate_event.EventType type = 4 [json_name = "type"];
inline void DebateEvent::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::debate_event::EventType DebateEvent::type() const {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.type)
  return _internal_type();
}
inline void DebateEvent::set_type(::debate_event::EventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:debate_event.DebateEvent.type)
}
inline ::debate_event::EventType DebateEvent::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::debate_event::EventType>(_impl_.type_);
}
inline void DebateEvent::_internal_set_type(::debate_event::EventType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .debate_event.CreateDebate create_debate = 10 [json_name = "createDebate"];
inline bool DebateEvent::has_create_debate() const {
  return payload_case() == kCreateDebate;
}
inline bool DebateEvent::_internal_has_create_debate() const {
  return payload_case() == kCreateDebate;
}
inline void DebateEvent::set_has_create_debate() {
  _impl_._oneof_case_[0] = kCreateDebate;
}
inline void DebateEvent::clear_create_debate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kCreateDebate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.create_debate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.create_debate_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::CreateDebate* DebateEvent::release_create_debate() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.create_debate)
  if (payload_case() == kCreateDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.create_debate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.create_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::CreateDebate& DebateEvent::_internal_create_debate() const {
  return payload_case() == kCreateDebate ? *_impl_.payload_.create_debate_ : reinterpret_cast<::debate_event::CreateDebate&>(::debate_event::_CreateDebate_default_instance_);
}
inline const ::debate_event::CreateDebate& DebateEvent::create_debate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.create_debate)
  return _internal_create_debate();
}
inline ::debate_event::CreateDebate* DebateEvent::unsafe_arena_release_create_debate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.create_debate)
  if (payload_case() == kCreateDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.create_debate_;
    _impl_.payload_.create_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_create_debate(::debate_event::CreateDebate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_create_debate();
    _impl_.payload_.create_debate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.create_debate)
}
inline ::debate_event::CreateDebate* DebateEvent::_internal_mutable_create_debate() {
  if (payload_case() != kCreateDebate) {
    clear_payload();
    set_has_create_debate();
    _impl_.payload_.create_debate_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::CreateDebate>(GetArena());
  }
  return _impl_.payload_.create_debate_;
}
inline ::debate_event::CreateDebate* DebateEvent::mutable_create_debate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::CreateDebate* _msg = _internal_mutable_create_debate();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.create_debate)
  return _msg;
}

// .debate_event.ClearDebates clear_debates = 11 [json_name = "clearDebates"];
inline bool DebateEvent::has_clear_debates() const {
  return payload_case() == kClearDebates;
}
inline bool DebateEvent::_internal_has_clear_debates() const {
  return payload_case() == kClearDebates;
}
inline void DebateEvent::set_has_clear_debates() {
  _impl_._oneof_case_[0] = kClearDebates;
}
inline void DebateEvent::clear_clear_debates() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kClearDebates) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.clear_debates_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.clear_debates_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::ClearDebates* DebateEvent::release_clear_debates() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.clear_debates)
  if (payload_case() == kClearDebates) {
    clear_has_payload();
    auto* temp = _impl_.payload_.clear_debates_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.clear_debates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::ClearDebates& DebateEvent::_internal_clear_debates() const {
  return payload_case() == kClearDebates ? *_impl_.payload_.clear_debates_ : reinterpret_cast<::debate_event::ClearDebates&>(::debate_event::_ClearDebates_default_instance_);
}
inline const ::debate_event::ClearDebates& DebateEvent::clear_debates() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.clear_debates)
  return _internal_clear_debates();
}
inline ::debate_event::ClearDebates* DebateEvent::unsafe_arena_release_clear_debates() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.clear_debates)
  if (payload_case() == kClearDebates) {
    clear_has_payload();
    auto* temp = _impl_.payload_.clear_debates_;
    _impl_.payload_.clear_debates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_clear_debates(::debate_event::ClearDebates* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_clear_debates();
    _impl_.payload_.clear_debates_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.clear_debates)
}
inline ::debate_event::ClearDebates* DebateEvent::_internal_mutable_clear_debates() {
  if (payload_case() != kClearDebates) {
    clear_payload();
    set_has_clear_debates();
    _impl_.payload_.clear_debates_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::ClearDebates>(GetArena());
  }
  return _impl_.payload_.clear_debates_;
}
inline ::debate_event::ClearDebates* DebateEvent::mutable_clear_debates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::ClearDebates* _msg = _internal_mutable_clear_debates();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.clear_debates)
  return _msg;
}

// .debate_event.DeleteDebate delete_debate = 12 [json_name = "deleteDebate"];
inline bool DebateEvent::has_delete_debate() const {
  return payload_case() == kDeleteDebate;
}
inline bool DebateEvent::_internal_has_delete_debate() const {
  return payload_case() == kDeleteDebate;
}
inline void DebateEvent::set_has_delete_debate() {
  _impl_._oneof_case_[0] = kDeleteDebate;
}
inline void DebateEvent::clear_delete_debate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteDebate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.delete_debate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.delete_debate_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::DeleteDebate* DebateEvent::release_delete_debate() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.delete_debate)
  if (payload_case() == kDeleteDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_debate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::DeleteDebate& DebateEvent::_internal_delete_debate() const {
  return payload_case() == kDeleteDebate ? *_impl_.payload_.delete_debate_ : reinterpret_cast<::debate_event::DeleteDebate&>(::debate_event::_DeleteDebate_default_instance_);
}
inline const ::debate_event::DeleteDebate& DebateEvent::delete_debate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.delete_debate)
  return _internal_delete_debate();
}
inline ::debate_event::DeleteDebate* DebateEvent::unsafe_arena_release_delete_debate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.delete_debate)
  if (payload_case() == kDeleteDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_debate_;
    _impl_.payload_.delete_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_delete_debate(::debate_event::DeleteDebate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_delete_debate();
    _impl_.payload_.delete_debate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.delete_debate)
}
inline ::debate_event::DeleteDebate* DebateEvent::_internal_mutable_delete_debate() {
  if (payload_case() != kDeleteDebate) {
    clear_payload();
    set_has_delete_debate();
    _impl_.payload_.delete_debate_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::DeleteDebate>(GetArena());
  }
  return _impl_.payload_.delete_debate_;
}
inline ::debate_event::DeleteDebate* DebateEvent::mutable_delete_debate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::DeleteDebate* _msg = _internal_mutable_delete_debate();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.delete_debate)
  return _msg;
}

// .debate_event.EnterDebate enter_debate = 13 [json_name = "enterDebate"];
inline bool DebateEvent::has_enter_debate() const {
  return payload_case() == kEnterDebate;
}
inline bool DebateEvent::_internal_has_enter_debate() const {
  return payload_case() == kEnterDebate;
}
inline void DebateEvent::set_has_enter_debate() {
  _impl_._oneof_case_[0] = kEnterDebate;
}
inline void DebateEvent::clear_enter_debate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kEnterDebate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.enter_debate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.enter_debate_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::EnterDebate* DebateEvent::release_enter_debate() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.enter_debate)
  if (payload_case() == kEnterDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.enter_debate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.enter_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::EnterDebate& DebateEvent::_internal_enter_debate() const {
  return payload_case() == kEnterDebate ? *_impl_.payload_.enter_debate_ : reinterpret_cast<::debate_event::EnterDebate&>(::debate_event::_EnterDebate_default_instance_);
}
inline const ::debate_event::EnterDebate& DebateEvent::enter_debate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.enter_debate)
  return _internal_enter_debate();
}
inline ::debate_event::EnterDebate* DebateEvent::unsafe_arena_release_enter_debate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.enter_debate)
  if (payload_case() == kEnterDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.enter_debate_;
    _impl_.payload_.enter_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_enter_debate(::debate_event::EnterDebate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_enter_debate();
    _impl_.payload_.enter_debate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.enter_debate)
}
inline ::debate_event::EnterDebate* DebateEvent::_internal_mutable_enter_debate() {
  if (payload_case() != kEnterDebate) {
    clear_payload();
    set_has_enter_debate();
    _impl_.payload_.enter_debate_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::EnterDebate>(GetArena());
  }
  return _impl_.payload_.enter_debate_;
}
inline ::debate_event::EnterDebate* DebateEvent::mutable_enter_debate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::EnterDebate* _msg = _internal_mutable_enter_debate();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.enter_debate)
  return _msg;
}

// .debate_event.GoHome go_home = 14 [json_name = "goHome"];
inline bool DebateEvent::has_go_home() const {
  return payload_case() == kGoHome;
}
inline bool DebateEvent::_internal_has_go_home() const {
  return payload_case() == kGoHome;
}
inline void DebateEvent::set_has_go_home() {
  _impl_._oneof_case_[0] = kGoHome;
}
inline void DebateEvent::clear_go_home() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGoHome) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.go_home_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.go_home_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::GoHome* DebateEvent::release_go_home() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.go_home)
  if (payload_case() == kGoHome) {
    clear_has_payload();
    auto* temp = _impl_.payload_.go_home_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.go_home_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::GoHome& DebateEvent::_internal_go_home() const {
  return payload_case() == kGoHome ? *_impl_.payload_.go_home_ : reinterpret_cast<::debate_event::GoHome&>(::debate_event::_GoHome_default_instance_);
}
inline const ::debate_event::GoHome& DebateEvent::go_home() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.go_home)
  return _internal_go_home();
}
inline ::debate_event::GoHome* DebateEvent::unsafe_arena_release_go_home() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.go_home)
  if (payload_case() == kGoHome) {
    clear_has_payload();
    auto* temp = _impl_.payload_.go_home_;
    _impl_.payload_.go_home_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_go_home(::debate_event::GoHome* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_go_home();
    _impl_.payload_.go_home_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.go_home)
}
inline ::debate_event::GoHome* DebateEvent::_internal_mutable_go_home() {
  if (payload_case() != kGoHome) {
    clear_payload();
    set_has_go_home();
    _impl_.payload_.go_home_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::GoHome>(GetArena());
  }
  return _impl_.payload_.go_home_;
}
inline ::debate_event::GoHome* DebateEvent::mutable_go_home() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::GoHome* _msg = _internal_mutable_go_home();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.go_home)
  return _msg;
}

inline bool DebateEvent::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void DebateEvent::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline DebateEvent::PayloadCase DebateEvent::payload_case() const {
  return DebateEvent::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace debate_event


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::debate_event::EventType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::debate_event::EventType>() {
  return ::debate_event::EventType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // debate_5fevent_2eproto_2epb_2eh
