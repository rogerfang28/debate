// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: debate_event.proto
// Protobuf C++ Version: 5.29.5

#ifndef debate_5fevent_2eproto_2epb_2eh
#define debate_5fevent_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029005
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_debate_5fevent_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_debate_5fevent_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_debate_5fevent_2eproto;
namespace debate_event {
class AddChildClaim;
struct AddChildClaimDefaultTypeInternal;
extern AddChildClaimDefaultTypeInternal _AddChildClaim_default_instance_;
class AddClaimToBeChallenged;
struct AddClaimToBeChallengedDefaultTypeInternal;
extern AddClaimToBeChallengedDefaultTypeInternal _AddClaimToBeChallenged_default_instance_;
class AddConnection;
struct AddConnectionDefaultTypeInternal;
extern AddConnectionDefaultTypeInternal _AddConnection_default_instance_;
class AddLinkToBeChallenged;
struct AddLinkToBeChallengedDefaultTypeInternal;
extern AddLinkToBeChallengedDefaultTypeInternal _AddLinkToBeChallenged_default_instance_;
class ConcedeChallenge;
struct ConcedeChallengeDefaultTypeInternal;
extern ConcedeChallengeDefaultTypeInternal _ConcedeChallenge_default_instance_;
class ConnectFromClaim;
struct ConnectFromClaimDefaultTypeInternal;
extern ConnectFromClaimDefaultTypeInternal _ConnectFromClaim_default_instance_;
class ConnectToClaim;
struct ConnectToClaimDefaultTypeInternal;
extern ConnectToClaimDefaultTypeInternal _ConnectToClaim_default_instance_;
class CreateDebate;
struct CreateDebateDefaultTypeInternal;
extern CreateDebateDefaultTypeInternal _CreateDebate_default_instance_;
class DebateEvent;
struct DebateEventDefaultTypeInternal;
extern DebateEventDefaultTypeInternal _DebateEvent_default_instance_;
class DeleteChallenge;
struct DeleteChallengeDefaultTypeInternal;
extern DeleteChallengeDefaultTypeInternal _DeleteChallenge_default_instance_;
class DeleteChildClaim;
struct DeleteChildClaimDefaultTypeInternal;
extern DeleteChildClaimDefaultTypeInternal _DeleteChildClaim_default_instance_;
class DeleteDebate;
struct DeleteDebateDefaultTypeInternal;
extern DeleteDebateDefaultTypeInternal _DeleteDebate_default_instance_;
class DeleteLink;
struct DeleteLinkDefaultTypeInternal;
extern DeleteLinkDefaultTypeInternal _DeleteLink_default_instance_;
class EnterDebate;
struct EnterDebateDefaultTypeInternal;
extern EnterDebateDefaultTypeInternal _EnterDebate_default_instance_;
class GoToChallenge;
struct GoToChallengeDefaultTypeInternal;
extern GoToChallengeDefaultTypeInternal _GoToChallenge_default_instance_;
class GoToClaim;
struct GoToClaimDefaultTypeInternal;
extern GoToClaimDefaultTypeInternal _GoToClaim_default_instance_;
class JoinDebate;
struct JoinDebateDefaultTypeInternal;
extern JoinDebateDefaultTypeInternal _JoinDebate_default_instance_;
class Login;
struct LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class RemoveClaimToBeChallenged;
struct RemoveClaimToBeChallengedDefaultTypeInternal;
extern RemoveClaimToBeChallengedDefaultTypeInternal _RemoveClaimToBeChallenged_default_instance_;
class RemoveLinkToBeChallenged;
struct RemoveLinkToBeChallengedDefaultTypeInternal;
extern RemoveLinkToBeChallengedDefaultTypeInternal _RemoveLinkToBeChallenged_default_instance_;
class SubmitChallengeClaim;
struct SubmitChallengeClaimDefaultTypeInternal;
extern SubmitChallengeClaimDefaultTypeInternal _SubmitChallengeClaim_default_instance_;
class SubmitConnectClaims;
struct SubmitConnectClaimsDefaultTypeInternal;
extern SubmitConnectClaimsDefaultTypeInternal _SubmitConnectClaims_default_instance_;
class SubmitEditClaim;
struct SubmitEditClaimDefaultTypeInternal;
extern SubmitEditClaimDefaultTypeInternal _SubmitEditClaim_default_instance_;
class SubmitEditClaimDescription;
struct SubmitEditClaimDescriptionDefaultTypeInternal;
extern SubmitEditClaimDescriptionDefaultTypeInternal _SubmitEditClaimDescription_default_instance_;
class UserAuthInfo;
struct UserAuthInfoDefaultTypeInternal;
extern UserAuthInfoDefaultTypeInternal _UserAuthInfo_default_instance_;
}  // namespace debate_event
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace debate_event {
enum EventType : int {
  EVENT_KIND_UNSPECIFIED = 0,
  NONE = 1,
  CREATE_DEBATE = 2,
  CLEAR_DEBATES = 3,
  DELETE_DEBATE = 4,
  ENTER_DEBATE = 5,
  GO_HOME = 6,
  GO_TO_PARENT = 7,
  OPEN_ADD_CHILD_CLAIM = 8,
  ADD_CHILD_CLAIM = 9,
  DELETE_CURRENT_STATEMENT = 10,
  REPORT_CLAIM = 11,
  GO_TO_CLAIM = 12,
  CLOSE_ADD_CHILD_CLAIM = 13,
  CLOSE_REPORT_CLAIM = 14,
  SUBMIT_ADD_CHILD_CLAIM = 15,
  DELETE_CHILD_CLAIM = 16,
  START_EDIT_CLAIM_DESCRIPTION = 17,
  SUBMIT_EDIT_CLAIM_DESCRIPTION = 18,
  CANCEL_EDIT_CLAIM_DESCRIPTION = 19,
  START_EDIT_CLAIM = 20,
  SUBMIT_EDIT_CLAIM = 21,
  CANCEL_EDIT_CLAIM = 22,
  CONNECT_FROM_CLAIM = 23,
  CONNECT_TO_CLAIM = 24,
  SUBMIT_CONNECT_CLAIMS = 25,
  CANCEL_CONNECT_CLAIMS = 26,
  DELETE_LINK = 27,
  JOIN_DEBATE = 28,
  LOGIN = 29,
  LOGOUT = 30,
  START_CHALLENGE_CLAIM = 31,
  ADD_CLAIM_TO_BE_CHALLENGED = 32,
  ADD_LINK_TO_BE_CHALLENGED = 33,
  SUBMIT_CHALLENGE_CLAIM = 34,
  GO_TO_CHALLENGE = 35,
  CONCEDE_CHALLENGE = 36,
  CANCEL_CHALLENGE_CLAIM = 37,
  OPEN_ADD_CHALLENGE = 38,
  CLOSE_ADD_CHALLENGE = 39,
  REMOVE_CLAIM_TO_BE_CHALLENGED = 40,
  REMOVE_LINK_TO_BE_CHALLENGED = 41,
  DELETE_CHALLENGE = 42,
  GO_TO_CHALLENGED_PARENT_CLAIM = 43,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool EventType_IsValid(int value);
extern const uint32_t EventType_internal_data_[];
constexpr EventType EventType_MIN = static_cast<EventType>(0);
constexpr EventType EventType_MAX = static_cast<EventType>(43);
constexpr int EventType_ARRAYSIZE = 43 + 1;
const ::google::protobuf::EnumDescriptor*
EventType_descriptor();
template <typename T>
const std::string& EventType_Name(T value) {
  static_assert(std::is_same<T, EventType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EventType_Name().");
  return EventType_Name(static_cast<EventType>(value));
}
template <>
inline const std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EventType_descriptor,
                                                 0, 43>(
      static_cast<int>(value));
}
inline bool EventType_Parse(absl::string_view name, EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(
      EventType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UserAuthInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.UserAuthInfo) */ {
 public:
  inline UserAuthInfo() : UserAuthInfo(nullptr) {}
  ~UserAuthInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UserAuthInfo* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UserAuthInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserAuthInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserAuthInfo(const UserAuthInfo& from) : UserAuthInfo(nullptr, from) {}
  inline UserAuthInfo(UserAuthInfo&& from) noexcept
      : UserAuthInfo(nullptr, std::move(from)) {}
  inline UserAuthInfo& operator=(const UserAuthInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAuthInfo& operator=(UserAuthInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAuthInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAuthInfo* internal_default_instance() {
    return reinterpret_cast<const UserAuthInfo*>(
        &_UserAuthInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(UserAuthInfo& a, UserAuthInfo& b) { a.Swap(&b); }
  inline void Swap(UserAuthInfo* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAuthInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAuthInfo* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UserAuthInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserAuthInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserAuthInfo& from) { UserAuthInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UserAuthInfo* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.UserAuthInfo"; }

 protected:
  explicit UserAuthInfo(::google::protobuf::Arena* arena);
  UserAuthInfo(::google::protobuf::Arena* arena, const UserAuthInfo& from);
  UserAuthInfo(::google::protobuf::Arena* arena, UserAuthInfo&& from) noexcept
      : UserAuthInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kIsLoggedInFieldNumber = 3,
  };
  // string username = 1 [json_name = "username"];
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // int32 user_id = 2 [json_name = "userId"];
  void clear_user_id() ;
  ::int32_t user_id() const;
  void set_user_id(::int32_t value);

  private:
  ::int32_t _internal_user_id() const;
  void _internal_set_user_id(::int32_t value);

  public:
  // bool is_logged_in = 3 [json_name = "isLoggedIn"];
  void clear_is_logged_in() ;
  bool is_logged_in() const;
  void set_is_logged_in(bool value);

  private:
  bool _internal_is_logged_in() const;
  void _internal_set_is_logged_in(bool value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.UserAuthInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      42, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UserAuthInfo& from_msg);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::int32_t user_id_;
    bool is_logged_in_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class SubmitEditClaimDescription final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.SubmitEditClaimDescription) */ {
 public:
  inline SubmitEditClaimDescription() : SubmitEditClaimDescription(nullptr) {}
  ~SubmitEditClaimDescription() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubmitEditClaimDescription* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubmitEditClaimDescription));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubmitEditClaimDescription(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubmitEditClaimDescription(const SubmitEditClaimDescription& from) : SubmitEditClaimDescription(nullptr, from) {}
  inline SubmitEditClaimDescription(SubmitEditClaimDescription&& from) noexcept
      : SubmitEditClaimDescription(nullptr, std::move(from)) {}
  inline SubmitEditClaimDescription& operator=(const SubmitEditClaimDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitEditClaimDescription& operator=(SubmitEditClaimDescription&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitEditClaimDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitEditClaimDescription* internal_default_instance() {
    return reinterpret_cast<const SubmitEditClaimDescription*>(
        &_SubmitEditClaimDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SubmitEditClaimDescription& a, SubmitEditClaimDescription& b) { a.Swap(&b); }
  inline void Swap(SubmitEditClaimDescription* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitEditClaimDescription* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitEditClaimDescription* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubmitEditClaimDescription>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubmitEditClaimDescription& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubmitEditClaimDescription& from) { SubmitEditClaimDescription::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubmitEditClaimDescription* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.SubmitEditClaimDescription"; }

 protected:
  explicit SubmitEditClaimDescription(::google::protobuf::Arena* arena);
  SubmitEditClaimDescription(::google::protobuf::Arena* arena, const SubmitEditClaimDescription& from);
  SubmitEditClaimDescription(::google::protobuf::Arena* arena, SubmitEditClaimDescription&& from) noexcept
      : SubmitEditClaimDescription(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewDescriptionFieldNumber = 1,
  };
  // string new_description = 1 [json_name = "newDescription"];
  void clear_new_description() ;
  const std::string& new_description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_description(Arg_&& arg, Args_... args);
  std::string* mutable_new_description();
  PROTOBUF_NODISCARD std::string* release_new_description();
  void set_allocated_new_description(std::string* value);

  private:
  const std::string& _internal_new_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_description(
      const std::string& value);
  std::string* _internal_mutable_new_description();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.SubmitEditClaimDescription)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      63, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubmitEditClaimDescription& from_msg);
    ::google::protobuf::internal::ArenaStringPtr new_description_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class SubmitEditClaim final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.SubmitEditClaim) */ {
 public:
  inline SubmitEditClaim() : SubmitEditClaim(nullptr) {}
  ~SubmitEditClaim() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubmitEditClaim* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubmitEditClaim));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubmitEditClaim(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubmitEditClaim(const SubmitEditClaim& from) : SubmitEditClaim(nullptr, from) {}
  inline SubmitEditClaim(SubmitEditClaim&& from) noexcept
      : SubmitEditClaim(nullptr, std::move(from)) {}
  inline SubmitEditClaim& operator=(const SubmitEditClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitEditClaim& operator=(SubmitEditClaim&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitEditClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitEditClaim* internal_default_instance() {
    return reinterpret_cast<const SubmitEditClaim*>(
        &_SubmitEditClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SubmitEditClaim& a, SubmitEditClaim& b) { a.Swap(&b); }
  inline void Swap(SubmitEditClaim* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitEditClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitEditClaim* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubmitEditClaim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubmitEditClaim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubmitEditClaim& from) { SubmitEditClaim::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubmitEditClaim* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.SubmitEditClaim"; }

 protected:
  explicit SubmitEditClaim(::google::protobuf::Arena* arena);
  SubmitEditClaim(::google::protobuf::Arena* arena, const SubmitEditClaim& from);
  SubmitEditClaim(::google::protobuf::Arena* arena, SubmitEditClaim&& from) noexcept
      : SubmitEditClaim(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewClaimFieldNumber = 1,
  };
  // string new_claim = 1 [json_name = "newClaim"];
  void clear_new_claim() ;
  const std::string& new_claim() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_claim(Arg_&& arg, Args_... args);
  std::string* mutable_new_claim();
  PROTOBUF_NODISCARD std::string* release_new_claim();
  void set_allocated_new_claim(std::string* value);

  private:
  const std::string& _internal_new_claim() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_claim(
      const std::string& value);
  std::string* _internal_mutable_new_claim();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.SubmitEditClaim)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubmitEditClaim& from_msg);
    ::google::protobuf::internal::ArenaStringPtr new_claim_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class SubmitConnectClaims final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.SubmitConnectClaims) */ {
 public:
  inline SubmitConnectClaims() : SubmitConnectClaims(nullptr) {}
  ~SubmitConnectClaims() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubmitConnectClaims* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubmitConnectClaims));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubmitConnectClaims(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubmitConnectClaims(const SubmitConnectClaims& from) : SubmitConnectClaims(nullptr, from) {}
  inline SubmitConnectClaims(SubmitConnectClaims&& from) noexcept
      : SubmitConnectClaims(nullptr, std::move(from)) {}
  inline SubmitConnectClaims& operator=(const SubmitConnectClaims& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitConnectClaims& operator=(SubmitConnectClaims&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitConnectClaims& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitConnectClaims* internal_default_instance() {
    return reinterpret_cast<const SubmitConnectClaims*>(
        &_SubmitConnectClaims_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SubmitConnectClaims& a, SubmitConnectClaims& b) { a.Swap(&b); }
  inline void Swap(SubmitConnectClaims* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitConnectClaims* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitConnectClaims* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubmitConnectClaims>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubmitConnectClaims& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubmitConnectClaims& from) { SubmitConnectClaims::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubmitConnectClaims* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.SubmitConnectClaims"; }

 protected:
  explicit SubmitConnectClaims(::google::protobuf::Arena* arena);
  SubmitConnectClaims(::google::protobuf::Arena* arena, const SubmitConnectClaims& from);
  SubmitConnectClaims(::google::protobuf::Arena* arena, SubmitConnectClaims&& from) noexcept
      : SubmitConnectClaims(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConnectionFieldNumber = 1,
    kFromClaimIdFieldNumber = 2,
    kToClaimIdFieldNumber = 3,
  };
  // string connection = 1 [json_name = "connection"];
  void clear_connection() ;
  const std::string& connection() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connection(Arg_&& arg, Args_... args);
  std::string* mutable_connection();
  PROTOBUF_NODISCARD std::string* release_connection();
  void set_allocated_connection(std::string* value);

  private:
  const std::string& _internal_connection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection(
      const std::string& value);
  std::string* _internal_mutable_connection();

  public:
  // int32 from_claim_id = 2 [json_name = "fromClaimId"];
  void clear_from_claim_id() ;
  ::int32_t from_claim_id() const;
  void set_from_claim_id(::int32_t value);

  private:
  ::int32_t _internal_from_claim_id() const;
  void _internal_set_from_claim_id(::int32_t value);

  public:
  // int32 to_claim_id = 3 [json_name = "toClaimId"];
  void clear_to_claim_id() ;
  ::int32_t to_claim_id() const;
  void set_to_claim_id(::int32_t value);

  private:
  ::int32_t _internal_to_claim_id() const;
  void _internal_set_to_claim_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.SubmitConnectClaims)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubmitConnectClaims& from_msg);
    ::google::protobuf::internal::ArenaStringPtr connection_;
    ::int32_t from_claim_id_;
    ::int32_t to_claim_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class SubmitChallengeClaim final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.SubmitChallengeClaim) */ {
 public:
  inline SubmitChallengeClaim() : SubmitChallengeClaim(nullptr) {}
  ~SubmitChallengeClaim() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SubmitChallengeClaim* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SubmitChallengeClaim));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SubmitChallengeClaim(
      ::google::protobuf::internal::ConstantInitialized);

  inline SubmitChallengeClaim(const SubmitChallengeClaim& from) : SubmitChallengeClaim(nullptr, from) {}
  inline SubmitChallengeClaim(SubmitChallengeClaim&& from) noexcept
      : SubmitChallengeClaim(nullptr, std::move(from)) {}
  inline SubmitChallengeClaim& operator=(const SubmitChallengeClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubmitChallengeClaim& operator=(SubmitChallengeClaim&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubmitChallengeClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubmitChallengeClaim* internal_default_instance() {
    return reinterpret_cast<const SubmitChallengeClaim*>(
        &_SubmitChallengeClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(SubmitChallengeClaim& a, SubmitChallengeClaim& b) { a.Swap(&b); }
  inline void Swap(SubmitChallengeClaim* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubmitChallengeClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubmitChallengeClaim* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SubmitChallengeClaim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SubmitChallengeClaim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SubmitChallengeClaim& from) { SubmitChallengeClaim::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SubmitChallengeClaim* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.SubmitChallengeClaim"; }

 protected:
  explicit SubmitChallengeClaim(::google::protobuf::Arena* arena);
  SubmitChallengeClaim(::google::protobuf::Arena* arena, const SubmitChallengeClaim& from);
  SubmitChallengeClaim(::google::protobuf::Arena* arena, SubmitChallengeClaim&& from) noexcept
      : SubmitChallengeClaim(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChallengeSentenceFieldNumber = 1,
  };
  // string challenge_sentence = 1 [json_name = "challengeSentence"];
  void clear_challenge_sentence() ;
  const std::string& challenge_sentence() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_challenge_sentence(Arg_&& arg, Args_... args);
  std::string* mutable_challenge_sentence();
  PROTOBUF_NODISCARD std::string* release_challenge_sentence();
  void set_allocated_challenge_sentence(std::string* value);

  private:
  const std::string& _internal_challenge_sentence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_challenge_sentence(
      const std::string& value);
  std::string* _internal_mutable_challenge_sentence();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.SubmitChallengeClaim)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      60, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SubmitChallengeClaim& from_msg);
    ::google::protobuf::internal::ArenaStringPtr challenge_sentence_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class RemoveLinkToBeChallenged final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.RemoveLinkToBeChallenged) */ {
 public:
  inline RemoveLinkToBeChallenged() : RemoveLinkToBeChallenged(nullptr) {}
  ~RemoveLinkToBeChallenged() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoveLinkToBeChallenged* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoveLinkToBeChallenged));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoveLinkToBeChallenged(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoveLinkToBeChallenged(const RemoveLinkToBeChallenged& from) : RemoveLinkToBeChallenged(nullptr, from) {}
  inline RemoveLinkToBeChallenged(RemoveLinkToBeChallenged&& from) noexcept
      : RemoveLinkToBeChallenged(nullptr, std::move(from)) {}
  inline RemoveLinkToBeChallenged& operator=(const RemoveLinkToBeChallenged& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveLinkToBeChallenged& operator=(RemoveLinkToBeChallenged&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveLinkToBeChallenged& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveLinkToBeChallenged* internal_default_instance() {
    return reinterpret_cast<const RemoveLinkToBeChallenged*>(
        &_RemoveLinkToBeChallenged_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(RemoveLinkToBeChallenged& a, RemoveLinkToBeChallenged& b) { a.Swap(&b); }
  inline void Swap(RemoveLinkToBeChallenged* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveLinkToBeChallenged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveLinkToBeChallenged* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoveLinkToBeChallenged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoveLinkToBeChallenged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoveLinkToBeChallenged& from) { RemoveLinkToBeChallenged::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoveLinkToBeChallenged* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.RemoveLinkToBeChallenged"; }

 protected:
  explicit RemoveLinkToBeChallenged(::google::protobuf::Arena* arena);
  RemoveLinkToBeChallenged(::google::protobuf::Arena* arena, const RemoveLinkToBeChallenged& from);
  RemoveLinkToBeChallenged(::google::protobuf::Arena* arena, RemoveLinkToBeChallenged&& from) noexcept
      : RemoveLinkToBeChallenged(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLinkIdFieldNumber = 1,
  };
  // int32 link_id = 1 [json_name = "linkId"];
  void clear_link_id() ;
  ::int32_t link_id() const;
  void set_link_id(::int32_t value);

  private:
  ::int32_t _internal_link_id() const;
  void _internal_set_link_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.RemoveLinkToBeChallenged)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemoveLinkToBeChallenged& from_msg);
    ::int32_t link_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class RemoveClaimToBeChallenged final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.RemoveClaimToBeChallenged) */ {
 public:
  inline RemoveClaimToBeChallenged() : RemoveClaimToBeChallenged(nullptr) {}
  ~RemoveClaimToBeChallenged() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RemoveClaimToBeChallenged* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RemoveClaimToBeChallenged));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoveClaimToBeChallenged(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoveClaimToBeChallenged(const RemoveClaimToBeChallenged& from) : RemoveClaimToBeChallenged(nullptr, from) {}
  inline RemoveClaimToBeChallenged(RemoveClaimToBeChallenged&& from) noexcept
      : RemoveClaimToBeChallenged(nullptr, std::move(from)) {}
  inline RemoveClaimToBeChallenged& operator=(const RemoveClaimToBeChallenged& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveClaimToBeChallenged& operator=(RemoveClaimToBeChallenged&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveClaimToBeChallenged& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveClaimToBeChallenged* internal_default_instance() {
    return reinterpret_cast<const RemoveClaimToBeChallenged*>(
        &_RemoveClaimToBeChallenged_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RemoveClaimToBeChallenged& a, RemoveClaimToBeChallenged& b) { a.Swap(&b); }
  inline void Swap(RemoveClaimToBeChallenged* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveClaimToBeChallenged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveClaimToBeChallenged* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RemoveClaimToBeChallenged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoveClaimToBeChallenged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoveClaimToBeChallenged& from) { RemoveClaimToBeChallenged::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RemoveClaimToBeChallenged* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.RemoveClaimToBeChallenged"; }

 protected:
  explicit RemoveClaimToBeChallenged(::google::protobuf::Arena* arena);
  RemoveClaimToBeChallenged(::google::protobuf::Arena* arena, const RemoveClaimToBeChallenged& from);
  RemoveClaimToBeChallenged(::google::protobuf::Arena* arena, RemoveClaimToBeChallenged&& from) noexcept
      : RemoveClaimToBeChallenged(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClaimIdFieldNumber = 1,
  };
  // int32 claim_id = 1 [json_name = "claimId"];
  void clear_claim_id() ;
  ::int32_t claim_id() const;
  void set_claim_id(::int32_t value);

  private:
  ::int32_t _internal_claim_id() const;
  void _internal_set_claim_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.RemoveClaimToBeChallenged)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemoveClaimToBeChallenged& from_msg);
    ::int32_t claim_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class Login final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.Login) */ {
 public:
  inline Login() : Login(nullptr) {}
  ~Login() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Login* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Login));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Login(
      ::google::protobuf::internal::ConstantInitialized);

  inline Login(const Login& from) : Login(nullptr, from) {}
  inline Login(Login&& from) noexcept
      : Login(nullptr, std::move(from)) {}
  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
        &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(Login& a, Login& b) { a.Swap(&b); }
  inline void Swap(Login* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Login* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Login>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Login& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Login& from) { Login::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Login* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.Login"; }

 protected:
  explicit Login(::google::protobuf::Arena* arena);
  Login(::google::protobuf::Arena* arena, const Login& from);
  Login(::google::protobuf::Arena* arena, Login&& from) noexcept
      : Login(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1 [json_name = "username"];
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2 [json_name = "password"];
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.Login)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Login& from_msg);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class JoinDebate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.JoinDebate) */ {
 public:
  inline JoinDebate() : JoinDebate(nullptr) {}
  ~JoinDebate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(JoinDebate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(JoinDebate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR JoinDebate(
      ::google::protobuf::internal::ConstantInitialized);

  inline JoinDebate(const JoinDebate& from) : JoinDebate(nullptr, from) {}
  inline JoinDebate(JoinDebate&& from) noexcept
      : JoinDebate(nullptr, std::move(from)) {}
  inline JoinDebate& operator=(const JoinDebate& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinDebate& operator=(JoinDebate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinDebate& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinDebate* internal_default_instance() {
    return reinterpret_cast<const JoinDebate*>(
        &_JoinDebate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(JoinDebate& a, JoinDebate& b) { a.Swap(&b); }
  inline void Swap(JoinDebate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinDebate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinDebate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<JoinDebate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinDebate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const JoinDebate& from) { JoinDebate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(JoinDebate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.JoinDebate"; }

 protected:
  explicit JoinDebate(::google::protobuf::Arena* arena);
  JoinDebate(::google::protobuf::Arena* arena, const JoinDebate& from);
  JoinDebate(::google::protobuf::Arena* arena, JoinDebate&& from) noexcept
      : JoinDebate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDebateIdFieldNumber = 1,
  };
  // int32 debate_id = 1 [json_name = "debateId"];
  void clear_debate_id() ;
  ::int32_t debate_id() const;
  void set_debate_id(::int32_t value);

  private:
  ::int32_t _internal_debate_id() const;
  void _internal_set_debate_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.JoinDebate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const JoinDebate& from_msg);
    ::int32_t debate_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class GoToClaim final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.GoToClaim) */ {
 public:
  inline GoToClaim() : GoToClaim(nullptr) {}
  ~GoToClaim() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GoToClaim* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GoToClaim));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoToClaim(
      ::google::protobuf::internal::ConstantInitialized);

  inline GoToClaim(const GoToClaim& from) : GoToClaim(nullptr, from) {}
  inline GoToClaim(GoToClaim&& from) noexcept
      : GoToClaim(nullptr, std::move(from)) {}
  inline GoToClaim& operator=(const GoToClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoToClaim& operator=(GoToClaim&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoToClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoToClaim* internal_default_instance() {
    return reinterpret_cast<const GoToClaim*>(
        &_GoToClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(GoToClaim& a, GoToClaim& b) { a.Swap(&b); }
  inline void Swap(GoToClaim* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoToClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoToClaim* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GoToClaim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoToClaim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoToClaim& from) { GoToClaim::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GoToClaim* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.GoToClaim"; }

 protected:
  explicit GoToClaim(::google::protobuf::Arena* arena);
  GoToClaim(::google::protobuf::Arena* arena, const GoToClaim& from);
  GoToClaim(::google::protobuf::Arena* arena, GoToClaim&& from) noexcept
      : GoToClaim(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClaimIdFieldNumber = 2,
  };
  // int32 claim_id = 2 [json_name = "claimId"];
  void clear_claim_id() ;
  ::int32_t claim_id() const;
  void set_claim_id(::int32_t value);

  private:
  ::int32_t _internal_claim_id() const;
  void _internal_set_claim_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.GoToClaim)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GoToClaim& from_msg);
    ::int32_t claim_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class GoToChallenge final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.GoToChallenge) */ {
 public:
  inline GoToChallenge() : GoToChallenge(nullptr) {}
  ~GoToChallenge() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GoToChallenge* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GoToChallenge));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoToChallenge(
      ::google::protobuf::internal::ConstantInitialized);

  inline GoToChallenge(const GoToChallenge& from) : GoToChallenge(nullptr, from) {}
  inline GoToChallenge(GoToChallenge&& from) noexcept
      : GoToChallenge(nullptr, std::move(from)) {}
  inline GoToChallenge& operator=(const GoToChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoToChallenge& operator=(GoToChallenge&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoToChallenge& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoToChallenge* internal_default_instance() {
    return reinterpret_cast<const GoToChallenge*>(
        &_GoToChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(GoToChallenge& a, GoToChallenge& b) { a.Swap(&b); }
  inline void Swap(GoToChallenge* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoToChallenge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoToChallenge* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GoToChallenge>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoToChallenge& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoToChallenge& from) { GoToChallenge::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GoToChallenge* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.GoToChallenge"; }

 protected:
  explicit GoToChallenge(::google::protobuf::Arena* arena);
  GoToChallenge(::google::protobuf::Arena* arena, const GoToChallenge& from);
  GoToChallenge(::google::protobuf::Arena* arena, GoToChallenge&& from) noexcept
      : GoToChallenge(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChallengeIdFieldNumber = 1,
  };
  // int32 challenge_id = 1 [json_name = "challengeId"];
  void clear_challenge_id() ;
  ::int32_t challenge_id() const;
  void set_challenge_id(::int32_t value);

  private:
  ::int32_t _internal_challenge_id() const;
  void _internal_set_challenge_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.GoToChallenge)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GoToChallenge& from_msg);
    ::int32_t challenge_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class EnterDebate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.EnterDebate) */ {
 public:
  inline EnterDebate() : EnterDebate(nullptr) {}
  ~EnterDebate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EnterDebate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EnterDebate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EnterDebate(
      ::google::protobuf::internal::ConstantInitialized);

  inline EnterDebate(const EnterDebate& from) : EnterDebate(nullptr, from) {}
  inline EnterDebate(EnterDebate&& from) noexcept
      : EnterDebate(nullptr, std::move(from)) {}
  inline EnterDebate& operator=(const EnterDebate& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterDebate& operator=(EnterDebate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnterDebate& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnterDebate* internal_default_instance() {
    return reinterpret_cast<const EnterDebate*>(
        &_EnterDebate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(EnterDebate& a, EnterDebate& b) { a.Swap(&b); }
  inline void Swap(EnterDebate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterDebate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnterDebate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EnterDebate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EnterDebate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EnterDebate& from) { EnterDebate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EnterDebate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.EnterDebate"; }

 protected:
  explicit EnterDebate(::google::protobuf::Arena* arena);
  EnterDebate(::google::protobuf::Arena* arena, const EnterDebate& from);
  EnterDebate(::google::protobuf::Arena* arena, EnterDebate&& from) noexcept
      : EnterDebate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDebateIdFieldNumber = 1,
  };
  // int32 debate_id = 1 [json_name = "debateId"];
  void clear_debate_id() ;
  ::int32_t debate_id() const;
  void set_debate_id(::int32_t value);

  private:
  ::int32_t _internal_debate_id() const;
  void _internal_set_debate_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.EnterDebate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EnterDebate& from_msg);
    ::int32_t debate_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class DeleteLink final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.DeleteLink) */ {
 public:
  inline DeleteLink() : DeleteLink(nullptr) {}
  ~DeleteLink() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteLink* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteLink));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteLink(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteLink(const DeleteLink& from) : DeleteLink(nullptr, from) {}
  inline DeleteLink(DeleteLink&& from) noexcept
      : DeleteLink(nullptr, std::move(from)) {}
  inline DeleteLink& operator=(const DeleteLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteLink& operator=(DeleteLink&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteLink* internal_default_instance() {
    return reinterpret_cast<const DeleteLink*>(
        &_DeleteLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(DeleteLink& a, DeleteLink& b) { a.Swap(&b); }
  inline void Swap(DeleteLink* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteLink* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteLink* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteLink>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteLink& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteLink& from) { DeleteLink::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteLink* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.DeleteLink"; }

 protected:
  explicit DeleteLink(::google::protobuf::Arena* arena);
  DeleteLink(::google::protobuf::Arena* arena, const DeleteLink& from);
  DeleteLink(::google::protobuf::Arena* arena, DeleteLink&& from) noexcept
      : DeleteLink(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLinkIdFieldNumber = 1,
  };
  // int32 link_id = 1 [json_name = "linkId"];
  void clear_link_id() ;
  ::int32_t link_id() const;
  void set_link_id(::int32_t value);

  private:
  ::int32_t _internal_link_id() const;
  void _internal_set_link_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.DeleteLink)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteLink& from_msg);
    ::int32_t link_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class DeleteDebate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.DeleteDebate) */ {
 public:
  inline DeleteDebate() : DeleteDebate(nullptr) {}
  ~DeleteDebate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteDebate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteDebate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteDebate(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteDebate(const DeleteDebate& from) : DeleteDebate(nullptr, from) {}
  inline DeleteDebate(DeleteDebate&& from) noexcept
      : DeleteDebate(nullptr, std::move(from)) {}
  inline DeleteDebate& operator=(const DeleteDebate& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteDebate& operator=(DeleteDebate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteDebate& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteDebate* internal_default_instance() {
    return reinterpret_cast<const DeleteDebate*>(
        &_DeleteDebate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(DeleteDebate& a, DeleteDebate& b) { a.Swap(&b); }
  inline void Swap(DeleteDebate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteDebate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteDebate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteDebate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteDebate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteDebate& from) { DeleteDebate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteDebate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.DeleteDebate"; }

 protected:
  explicit DeleteDebate(::google::protobuf::Arena* arena);
  DeleteDebate(::google::protobuf::Arena* arena, const DeleteDebate& from);
  DeleteDebate(::google::protobuf::Arena* arena, DeleteDebate&& from) noexcept
      : DeleteDebate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDebateIdFieldNumber = 1,
  };
  // int32 debate_id = 1 [json_name = "debateId"];
  void clear_debate_id() ;
  ::int32_t debate_id() const;
  void set_debate_id(::int32_t value);

  private:
  ::int32_t _internal_debate_id() const;
  void _internal_set_debate_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.DeleteDebate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteDebate& from_msg);
    ::int32_t debate_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class DeleteChildClaim final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.DeleteChildClaim) */ {
 public:
  inline DeleteChildClaim() : DeleteChildClaim(nullptr) {}
  ~DeleteChildClaim() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteChildClaim* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteChildClaim));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteChildClaim(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteChildClaim(const DeleteChildClaim& from) : DeleteChildClaim(nullptr, from) {}
  inline DeleteChildClaim(DeleteChildClaim&& from) noexcept
      : DeleteChildClaim(nullptr, std::move(from)) {}
  inline DeleteChildClaim& operator=(const DeleteChildClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteChildClaim& operator=(DeleteChildClaim&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteChildClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteChildClaim* internal_default_instance() {
    return reinterpret_cast<const DeleteChildClaim*>(
        &_DeleteChildClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(DeleteChildClaim& a, DeleteChildClaim& b) { a.Swap(&b); }
  inline void Swap(DeleteChildClaim* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteChildClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteChildClaim* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteChildClaim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteChildClaim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteChildClaim& from) { DeleteChildClaim::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteChildClaim* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.DeleteChildClaim"; }

 protected:
  explicit DeleteChildClaim(::google::protobuf::Arena* arena);
  DeleteChildClaim(::google::protobuf::Arena* arena, const DeleteChildClaim& from);
  DeleteChildClaim(::google::protobuf::Arena* arena, DeleteChildClaim&& from) noexcept
      : DeleteChildClaim(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClaimIdFieldNumber = 2,
  };
  // int32 claim_id = 2 [json_name = "claimId"];
  void clear_claim_id() ;
  ::int32_t claim_id() const;
  void set_claim_id(::int32_t value);

  private:
  ::int32_t _internal_claim_id() const;
  void _internal_set_claim_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.DeleteChildClaim)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteChildClaim& from_msg);
    ::int32_t claim_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class DeleteChallenge final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.DeleteChallenge) */ {
 public:
  inline DeleteChallenge() : DeleteChallenge(nullptr) {}
  ~DeleteChallenge() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteChallenge* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteChallenge));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteChallenge(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteChallenge(const DeleteChallenge& from) : DeleteChallenge(nullptr, from) {}
  inline DeleteChallenge(DeleteChallenge&& from) noexcept
      : DeleteChallenge(nullptr, std::move(from)) {}
  inline DeleteChallenge& operator=(const DeleteChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteChallenge& operator=(DeleteChallenge&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteChallenge& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteChallenge* internal_default_instance() {
    return reinterpret_cast<const DeleteChallenge*>(
        &_DeleteChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(DeleteChallenge& a, DeleteChallenge& b) { a.Swap(&b); }
  inline void Swap(DeleteChallenge* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteChallenge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteChallenge* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteChallenge>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteChallenge& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteChallenge& from) { DeleteChallenge::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteChallenge* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.DeleteChallenge"; }

 protected:
  explicit DeleteChallenge(::google::protobuf::Arena* arena);
  DeleteChallenge(::google::protobuf::Arena* arena, const DeleteChallenge& from);
  DeleteChallenge(::google::protobuf::Arena* arena, DeleteChallenge&& from) noexcept
      : DeleteChallenge(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChallengeIdFieldNumber = 1,
  };
  // int32 challenge_id = 1 [json_name = "challengeId"];
  void clear_challenge_id() ;
  ::int32_t challenge_id() const;
  void set_challenge_id(::int32_t value);

  private:
  ::int32_t _internal_challenge_id() const;
  void _internal_set_challenge_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.DeleteChallenge)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteChallenge& from_msg);
    ::int32_t challenge_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class CreateDebate final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.CreateDebate) */ {
 public:
  inline CreateDebate() : CreateDebate(nullptr) {}
  ~CreateDebate() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateDebate* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateDebate));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateDebate(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateDebate(const CreateDebate& from) : CreateDebate(nullptr, from) {}
  inline CreateDebate(CreateDebate&& from) noexcept
      : CreateDebate(nullptr, std::move(from)) {}
  inline CreateDebate& operator=(const CreateDebate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDebate& operator=(CreateDebate&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDebate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDebate* internal_default_instance() {
    return reinterpret_cast<const CreateDebate*>(
        &_CreateDebate_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CreateDebate& a, CreateDebate& b) { a.Swap(&b); }
  inline void Swap(CreateDebate* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDebate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDebate* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateDebate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateDebate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateDebate& from) { CreateDebate::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateDebate* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.CreateDebate"; }

 protected:
  explicit CreateDebate(::google::protobuf::Arena* arena);
  CreateDebate(::google::protobuf::Arena* arena, const CreateDebate& from);
  CreateDebate(::google::protobuf::Arena* arena, CreateDebate&& from) noexcept
      : CreateDebate(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDebateTopicFieldNumber = 2,
  };
  // string debate_topic = 2 [json_name = "debateTopic"];
  void clear_debate_topic() ;
  const std::string& debate_topic() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_debate_topic(Arg_&& arg, Args_... args);
  std::string* mutable_debate_topic();
  PROTOBUF_NODISCARD std::string* release_debate_topic();
  void set_allocated_debate_topic(std::string* value);

  private:
  const std::string& _internal_debate_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debate_topic(
      const std::string& value);
  std::string* _internal_mutable_debate_topic();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.CreateDebate)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateDebate& from_msg);
    ::google::protobuf::internal::ArenaStringPtr debate_topic_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class ConnectToClaim final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.ConnectToClaim) */ {
 public:
  inline ConnectToClaim() : ConnectToClaim(nullptr) {}
  ~ConnectToClaim() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConnectToClaim* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConnectToClaim));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectToClaim(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConnectToClaim(const ConnectToClaim& from) : ConnectToClaim(nullptr, from) {}
  inline ConnectToClaim(ConnectToClaim&& from) noexcept
      : ConnectToClaim(nullptr, std::move(from)) {}
  inline ConnectToClaim& operator=(const ConnectToClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectToClaim& operator=(ConnectToClaim&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectToClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectToClaim* internal_default_instance() {
    return reinterpret_cast<const ConnectToClaim*>(
        &_ConnectToClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ConnectToClaim& a, ConnectToClaim& b) { a.Swap(&b); }
  inline void Swap(ConnectToClaim* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectToClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectToClaim* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConnectToClaim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectToClaim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConnectToClaim& from) { ConnectToClaim::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConnectToClaim* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.ConnectToClaim"; }

 protected:
  explicit ConnectToClaim(::google::protobuf::Arena* arena);
  ConnectToClaim(::google::protobuf::Arena* arena, const ConnectToClaim& from);
  ConnectToClaim(::google::protobuf::Arena* arena, ConnectToClaim&& from) noexcept
      : ConnectToClaim(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kToClaimIdFieldNumber = 2,
  };
  // int32 to_claim_id = 2 [json_name = "toClaimId"];
  void clear_to_claim_id() ;
  ::int32_t to_claim_id() const;
  void set_to_claim_id(::int32_t value);

  private:
  ::int32_t _internal_to_claim_id() const;
  void _internal_set_to_claim_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.ConnectToClaim)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConnectToClaim& from_msg);
    ::int32_t to_claim_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class ConnectFromClaim final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.ConnectFromClaim) */ {
 public:
  inline ConnectFromClaim() : ConnectFromClaim(nullptr) {}
  ~ConnectFromClaim() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConnectFromClaim* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConnectFromClaim));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConnectFromClaim(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConnectFromClaim(const ConnectFromClaim& from) : ConnectFromClaim(nullptr, from) {}
  inline ConnectFromClaim(ConnectFromClaim&& from) noexcept
      : ConnectFromClaim(nullptr, std::move(from)) {}
  inline ConnectFromClaim& operator=(const ConnectFromClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConnectFromClaim& operator=(ConnectFromClaim&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConnectFromClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConnectFromClaim* internal_default_instance() {
    return reinterpret_cast<const ConnectFromClaim*>(
        &_ConnectFromClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ConnectFromClaim& a, ConnectFromClaim& b) { a.Swap(&b); }
  inline void Swap(ConnectFromClaim* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConnectFromClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConnectFromClaim* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConnectFromClaim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConnectFromClaim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConnectFromClaim& from) { ConnectFromClaim::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConnectFromClaim* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.ConnectFromClaim"; }

 protected:
  explicit ConnectFromClaim(::google::protobuf::Arena* arena);
  ConnectFromClaim(::google::protobuf::Arena* arena, const ConnectFromClaim& from);
  ConnectFromClaim(::google::protobuf::Arena* arena, ConnectFromClaim&& from) noexcept
      : ConnectFromClaim(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromClaimIdFieldNumber = 1,
  };
  // int32 from_claim_id = 1 [json_name = "fromClaimId"];
  void clear_from_claim_id() ;
  ::int32_t from_claim_id() const;
  void set_from_claim_id(::int32_t value);

  private:
  ::int32_t _internal_from_claim_id() const;
  void _internal_set_from_claim_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.ConnectFromClaim)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConnectFromClaim& from_msg);
    ::int32_t from_claim_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class ConcedeChallenge final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.ConcedeChallenge) */ {
 public:
  inline ConcedeChallenge() : ConcedeChallenge(nullptr) {}
  ~ConcedeChallenge() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ConcedeChallenge* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ConcedeChallenge));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ConcedeChallenge(
      ::google::protobuf::internal::ConstantInitialized);

  inline ConcedeChallenge(const ConcedeChallenge& from) : ConcedeChallenge(nullptr, from) {}
  inline ConcedeChallenge(ConcedeChallenge&& from) noexcept
      : ConcedeChallenge(nullptr, std::move(from)) {}
  inline ConcedeChallenge& operator=(const ConcedeChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConcedeChallenge& operator=(ConcedeChallenge&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConcedeChallenge& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConcedeChallenge* internal_default_instance() {
    return reinterpret_cast<const ConcedeChallenge*>(
        &_ConcedeChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(ConcedeChallenge& a, ConcedeChallenge& b) { a.Swap(&b); }
  inline void Swap(ConcedeChallenge* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConcedeChallenge* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConcedeChallenge* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ConcedeChallenge>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ConcedeChallenge& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ConcedeChallenge& from) { ConcedeChallenge::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ConcedeChallenge* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.ConcedeChallenge"; }

 protected:
  explicit ConcedeChallenge(::google::protobuf::Arena* arena);
  ConcedeChallenge(::google::protobuf::Arena* arena, const ConcedeChallenge& from);
  ConcedeChallenge(::google::protobuf::Arena* arena, ConcedeChallenge&& from) noexcept
      : ConcedeChallenge(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChallengeIdFieldNumber = 1,
  };
  // int32 challenge_id = 1 [json_name = "challengeId"];
  void clear_challenge_id() ;
  ::int32_t challenge_id() const;
  void set_challenge_id(::int32_t value);

  private:
  ::int32_t _internal_challenge_id() const;
  void _internal_set_challenge_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.ConcedeChallenge)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ConcedeChallenge& from_msg);
    ::int32_t challenge_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class AddLinkToBeChallenged final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.AddLinkToBeChallenged) */ {
 public:
  inline AddLinkToBeChallenged() : AddLinkToBeChallenged(nullptr) {}
  ~AddLinkToBeChallenged() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddLinkToBeChallenged* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddLinkToBeChallenged));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddLinkToBeChallenged(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddLinkToBeChallenged(const AddLinkToBeChallenged& from) : AddLinkToBeChallenged(nullptr, from) {}
  inline AddLinkToBeChallenged(AddLinkToBeChallenged&& from) noexcept
      : AddLinkToBeChallenged(nullptr, std::move(from)) {}
  inline AddLinkToBeChallenged& operator=(const AddLinkToBeChallenged& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLinkToBeChallenged& operator=(AddLinkToBeChallenged&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLinkToBeChallenged& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddLinkToBeChallenged* internal_default_instance() {
    return reinterpret_cast<const AddLinkToBeChallenged*>(
        &_AddLinkToBeChallenged_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(AddLinkToBeChallenged& a, AddLinkToBeChallenged& b) { a.Swap(&b); }
  inline void Swap(AddLinkToBeChallenged* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLinkToBeChallenged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddLinkToBeChallenged* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddLinkToBeChallenged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddLinkToBeChallenged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddLinkToBeChallenged& from) { AddLinkToBeChallenged::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddLinkToBeChallenged* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.AddLinkToBeChallenged"; }

 protected:
  explicit AddLinkToBeChallenged(::google::protobuf::Arena* arena);
  AddLinkToBeChallenged(::google::protobuf::Arena* arena, const AddLinkToBeChallenged& from);
  AddLinkToBeChallenged(::google::protobuf::Arena* arena, AddLinkToBeChallenged&& from) noexcept
      : AddLinkToBeChallenged(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLinkIdFieldNumber = 1,
  };
  // int32 link_id = 1 [json_name = "linkId"];
  void clear_link_id() ;
  ::int32_t link_id() const;
  void set_link_id(::int32_t value);

  private:
  ::int32_t _internal_link_id() const;
  void _internal_set_link_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.AddLinkToBeChallenged)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AddLinkToBeChallenged& from_msg);
    ::int32_t link_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class AddConnection final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.AddConnection) */ {
 public:
  inline AddConnection() : AddConnection(nullptr) {}
  ~AddConnection() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddConnection* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddConnection));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddConnection(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddConnection(const AddConnection& from) : AddConnection(nullptr, from) {}
  inline AddConnection(AddConnection&& from) noexcept
      : AddConnection(nullptr, std::move(from)) {}
  inline AddConnection& operator=(const AddConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddConnection& operator=(AddConnection&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddConnection* internal_default_instance() {
    return reinterpret_cast<const AddConnection*>(
        &_AddConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AddConnection& a, AddConnection& b) { a.Swap(&b); }
  inline void Swap(AddConnection* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddConnection* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddConnection* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddConnection>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddConnection& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddConnection& from) { AddConnection::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddConnection* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.AddConnection"; }

 protected:
  explicit AddConnection(::google::protobuf::Arena* arena);
  AddConnection(::google::protobuf::Arena* arena, const AddConnection& from);
  AddConnection(::google::protobuf::Arena* arena, AddConnection&& from) noexcept
      : AddConnection(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConnectionFieldNumber = 5,
    kDebateIdFieldNumber = 2,
    kFromIdFieldNumber = 3,
    kToIdFieldNumber = 4,
  };
  // string connection = 5 [json_name = "connection"];
  void clear_connection() ;
  const std::string& connection() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connection(Arg_&& arg, Args_... args);
  std::string* mutable_connection();
  PROTOBUF_NODISCARD std::string* release_connection();
  void set_allocated_connection(std::string* value);

  private:
  const std::string& _internal_connection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection(
      const std::string& value);
  std::string* _internal_mutable_connection();

  public:
  // int32 debate_id = 2 [json_name = "debateId"];
  void clear_debate_id() ;
  ::int32_t debate_id() const;
  void set_debate_id(::int32_t value);

  private:
  ::int32_t _internal_debate_id() const;
  void _internal_set_debate_id(::int32_t value);

  public:
  // int32 from_id = 3 [json_name = "fromId"];
  void clear_from_id() ;
  ::int32_t from_id() const;
  void set_from_id(::int32_t value);

  private:
  ::int32_t _internal_from_id() const;
  void _internal_set_from_id(::int32_t value);

  public:
  // int32 to_id = 4 [json_name = "toId"];
  void clear_to_id() ;
  ::int32_t to_id() const;
  void set_to_id(::int32_t value);

  private:
  ::int32_t _internal_to_id() const;
  void _internal_set_to_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.AddConnection)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      45, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AddConnection& from_msg);
    ::google::protobuf::internal::ArenaStringPtr connection_;
    ::int32_t debate_id_;
    ::int32_t from_id_;
    ::int32_t to_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class AddClaimToBeChallenged final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.AddClaimToBeChallenged) */ {
 public:
  inline AddClaimToBeChallenged() : AddClaimToBeChallenged(nullptr) {}
  ~AddClaimToBeChallenged() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddClaimToBeChallenged* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddClaimToBeChallenged));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddClaimToBeChallenged(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddClaimToBeChallenged(const AddClaimToBeChallenged& from) : AddClaimToBeChallenged(nullptr, from) {}
  inline AddClaimToBeChallenged(AddClaimToBeChallenged&& from) noexcept
      : AddClaimToBeChallenged(nullptr, std::move(from)) {}
  inline AddClaimToBeChallenged& operator=(const AddClaimToBeChallenged& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddClaimToBeChallenged& operator=(AddClaimToBeChallenged&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddClaimToBeChallenged& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddClaimToBeChallenged* internal_default_instance() {
    return reinterpret_cast<const AddClaimToBeChallenged*>(
        &_AddClaimToBeChallenged_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(AddClaimToBeChallenged& a, AddClaimToBeChallenged& b) { a.Swap(&b); }
  inline void Swap(AddClaimToBeChallenged* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddClaimToBeChallenged* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddClaimToBeChallenged* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddClaimToBeChallenged>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddClaimToBeChallenged& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddClaimToBeChallenged& from) { AddClaimToBeChallenged::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddClaimToBeChallenged* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.AddClaimToBeChallenged"; }

 protected:
  explicit AddClaimToBeChallenged(::google::protobuf::Arena* arena);
  AddClaimToBeChallenged(::google::protobuf::Arena* arena, const AddClaimToBeChallenged& from);
  AddClaimToBeChallenged(::google::protobuf::Arena* arena, AddClaimToBeChallenged&& from) noexcept
      : AddClaimToBeChallenged(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClaimIdFieldNumber = 1,
  };
  // int32 claim_id = 1 [json_name = "claimId"];
  void clear_claim_id() ;
  ::int32_t claim_id() const;
  void set_claim_id(::int32_t value);

  private:
  ::int32_t _internal_claim_id() const;
  void _internal_set_claim_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:debate_event.AddClaimToBeChallenged)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AddClaimToBeChallenged& from_msg);
    ::int32_t claim_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class AddChildClaim final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.AddChildClaim) */ {
 public:
  inline AddChildClaim() : AddChildClaim(nullptr) {}
  ~AddChildClaim() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AddChildClaim* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AddChildClaim));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddChildClaim(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddChildClaim(const AddChildClaim& from) : AddChildClaim(nullptr, from) {}
  inline AddChildClaim(AddChildClaim&& from) noexcept
      : AddChildClaim(nullptr, std::move(from)) {}
  inline AddChildClaim& operator=(const AddChildClaim& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddChildClaim& operator=(AddChildClaim&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddChildClaim& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddChildClaim* internal_default_instance() {
    return reinterpret_cast<const AddChildClaim*>(
        &_AddChildClaim_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(AddChildClaim& a, AddChildClaim& b) { a.Swap(&b); }
  inline void Swap(AddChildClaim* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddChildClaim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddChildClaim* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AddChildClaim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddChildClaim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddChildClaim& from) { AddChildClaim::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AddChildClaim* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.AddChildClaim"; }

 protected:
  explicit AddChildClaim(::google::protobuf::Arena* arena);
  AddChildClaim(::google::protobuf::Arena* arena, const AddChildClaim& from);
  AddChildClaim(::google::protobuf::Arena* arena, AddChildClaim&& from) noexcept
      : AddChildClaim(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClaimFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // string claim = 1 [json_name = "claim"];
  void clear_claim() ;
  const std::string& claim() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_claim(Arg_&& arg, Args_... args);
  std::string* mutable_claim();
  PROTOBUF_NODISCARD std::string* release_claim();
  void set_allocated_claim(std::string* value);

  private:
  const std::string& _internal_claim() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_claim(
      const std::string& value);
  std::string* _internal_mutable_claim();

  public:
  // string description = 2 [json_name = "description"];
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // @@protoc_insertion_point(class_scope:debate_event.AddChildClaim)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AddChildClaim& from_msg);
    ::google::protobuf::internal::ArenaStringPtr claim_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};
// -------------------------------------------------------------------

class DebateEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:debate_event.DebateEvent) */ {
 public:
  inline DebateEvent() : DebateEvent(nullptr) {}
  ~DebateEvent() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DebateEvent* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DebateEvent));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DebateEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline DebateEvent(const DebateEvent& from) : DebateEvent(nullptr, from) {}
  inline DebateEvent(DebateEvent&& from) noexcept
      : DebateEvent(nullptr, std::move(from)) {}
  inline DebateEvent& operator=(const DebateEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebateEvent& operator=(DebateEvent&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebateEvent& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kCreateDebate = 10,
    kDeleteDebate = 12,
    kEnterDebate = 13,
    kAddChildClaim = 16,
    kGoToClaim = 20,
    kDeleteChildClaim = 23,
    kSubmitEditClaimDescription = 25,
    kSubmitEditClaim = 28,
    kConnectFromClaim = 30,
    kConnectToClaim = 31,
    kSubmitConnectClaims = 32,
    kDeleteLink = 34,
    kJoinDebate = 35,
    kLogin = 36,
    kAddClaimToBeChallenged = 38,
    kAddLinkToBeChallenged = 39,
    kSubmitChallengeClaim = 40,
    kGoToChallenge = 41,
    kConcedeChallenge = 42,
    kRemoveClaimToBeChallenged = 46,
    kRemoveLinkToBeChallenged = 47,
    kDeleteChallenge = 48,
    PAYLOAD_NOT_SET = 0,
  };
  static inline const DebateEvent* internal_default_instance() {
    return reinterpret_cast<const DebateEvent*>(
        &_DebateEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(DebateEvent& a, DebateEvent& b) { a.Swap(&b); }
  inline void Swap(DebateEvent* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebateEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebateEvent* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DebateEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DebateEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DebateEvent& from) { DebateEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DebateEvent* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "debate_event.DebateEvent"; }

 protected:
  explicit DebateEvent(::google::protobuf::Arena* arena);
  DebateEvent(::google::protobuf::Arena* arena, const DebateEvent& from);
  DebateEvent(::google::protobuf::Arena* arena, DebateEvent&& from) noexcept
      : DebateEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserFieldNumber = 1,
    kOccurredAtFieldNumber = 3,
    kTypeFieldNumber = 4,
    kCreateDebateFieldNumber = 10,
    kDeleteDebateFieldNumber = 12,
    kEnterDebateFieldNumber = 13,
    kAddChildClaimFieldNumber = 16,
    kGoToClaimFieldNumber = 20,
    kDeleteChildClaimFieldNumber = 23,
    kSubmitEditClaimDescriptionFieldNumber = 25,
    kSubmitEditClaimFieldNumber = 28,
    kConnectFromClaimFieldNumber = 30,
    kConnectToClaimFieldNumber = 31,
    kSubmitConnectClaimsFieldNumber = 32,
    kDeleteLinkFieldNumber = 34,
    kJoinDebateFieldNumber = 35,
    kLoginFieldNumber = 36,
    kAddClaimToBeChallengedFieldNumber = 38,
    kAddLinkToBeChallengedFieldNumber = 39,
    kSubmitChallengeClaimFieldNumber = 40,
    kGoToChallengeFieldNumber = 41,
    kConcedeChallengeFieldNumber = 42,
    kRemoveClaimToBeChallengedFieldNumber = 46,
    kRemoveLinkToBeChallengedFieldNumber = 47,
    kDeleteChallengeFieldNumber = 48,
  };
  // .debate_event.UserAuthInfo user = 1 [json_name = "user"];
  bool has_user() const;
  void clear_user() ;
  const ::debate_event::UserAuthInfo& user() const;
  PROTOBUF_NODISCARD ::debate_event::UserAuthInfo* release_user();
  ::debate_event::UserAuthInfo* mutable_user();
  void set_allocated_user(::debate_event::UserAuthInfo* value);
  void unsafe_arena_set_allocated_user(::debate_event::UserAuthInfo* value);
  ::debate_event::UserAuthInfo* unsafe_arena_release_user();

  private:
  const ::debate_event::UserAuthInfo& _internal_user() const;
  ::debate_event::UserAuthInfo* _internal_mutable_user();

  public:
  // .google.protobuf.Timestamp occurred_at = 3 [json_name = "occurredAt"];
  bool has_occurred_at() const;
  void clear_occurred_at() ;
  const ::google::protobuf::Timestamp& occurred_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_occurred_at();
  ::google::protobuf::Timestamp* mutable_occurred_at();
  void set_allocated_occurred_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_occurred_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_occurred_at();

  private:
  const ::google::protobuf::Timestamp& _internal_occurred_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_occurred_at();

  public:
  // .debate_event.EventType type = 4 [json_name = "type"];
  void clear_type() ;
  ::debate_event::EventType type() const;
  void set_type(::debate_event::EventType value);

  private:
  ::debate_event::EventType _internal_type() const;
  void _internal_set_type(::debate_event::EventType value);

  public:
  // .debate_event.CreateDebate create_debate = 10 [json_name = "createDebate"];
  bool has_create_debate() const;
  private:
  bool _internal_has_create_debate() const;

  public:
  void clear_create_debate() ;
  const ::debate_event::CreateDebate& create_debate() const;
  PROTOBUF_NODISCARD ::debate_event::CreateDebate* release_create_debate();
  ::debate_event::CreateDebate* mutable_create_debate();
  void set_allocated_create_debate(::debate_event::CreateDebate* value);
  void unsafe_arena_set_allocated_create_debate(::debate_event::CreateDebate* value);
  ::debate_event::CreateDebate* unsafe_arena_release_create_debate();

  private:
  const ::debate_event::CreateDebate& _internal_create_debate() const;
  ::debate_event::CreateDebate* _internal_mutable_create_debate();

  public:
  // .debate_event.DeleteDebate delete_debate = 12 [json_name = "deleteDebate"];
  bool has_delete_debate() const;
  private:
  bool _internal_has_delete_debate() const;

  public:
  void clear_delete_debate() ;
  const ::debate_event::DeleteDebate& delete_debate() const;
  PROTOBUF_NODISCARD ::debate_event::DeleteDebate* release_delete_debate();
  ::debate_event::DeleteDebate* mutable_delete_debate();
  void set_allocated_delete_debate(::debate_event::DeleteDebate* value);
  void unsafe_arena_set_allocated_delete_debate(::debate_event::DeleteDebate* value);
  ::debate_event::DeleteDebate* unsafe_arena_release_delete_debate();

  private:
  const ::debate_event::DeleteDebate& _internal_delete_debate() const;
  ::debate_event::DeleteDebate* _internal_mutable_delete_debate();

  public:
  // .debate_event.EnterDebate enter_debate = 13 [json_name = "enterDebate"];
  bool has_enter_debate() const;
  private:
  bool _internal_has_enter_debate() const;

  public:
  void clear_enter_debate() ;
  const ::debate_event::EnterDebate& enter_debate() const;
  PROTOBUF_NODISCARD ::debate_event::EnterDebate* release_enter_debate();
  ::debate_event::EnterDebate* mutable_enter_debate();
  void set_allocated_enter_debate(::debate_event::EnterDebate* value);
  void unsafe_arena_set_allocated_enter_debate(::debate_event::EnterDebate* value);
  ::debate_event::EnterDebate* unsafe_arena_release_enter_debate();

  private:
  const ::debate_event::EnterDebate& _internal_enter_debate() const;
  ::debate_event::EnterDebate* _internal_mutable_enter_debate();

  public:
  // .debate_event.AddChildClaim add_child_claim = 16 [json_name = "addChildClaim"];
  bool has_add_child_claim() const;
  private:
  bool _internal_has_add_child_claim() const;

  public:
  void clear_add_child_claim() ;
  const ::debate_event::AddChildClaim& add_child_claim() const;
  PROTOBUF_NODISCARD ::debate_event::AddChildClaim* release_add_child_claim();
  ::debate_event::AddChildClaim* mutable_add_child_claim();
  void set_allocated_add_child_claim(::debate_event::AddChildClaim* value);
  void unsafe_arena_set_allocated_add_child_claim(::debate_event::AddChildClaim* value);
  ::debate_event::AddChildClaim* unsafe_arena_release_add_child_claim();

  private:
  const ::debate_event::AddChildClaim& _internal_add_child_claim() const;
  ::debate_event::AddChildClaim* _internal_mutable_add_child_claim();

  public:
  // .debate_event.GoToClaim go_to_claim = 20 [json_name = "goToClaim"];
  bool has_go_to_claim() const;
  private:
  bool _internal_has_go_to_claim() const;

  public:
  void clear_go_to_claim() ;
  const ::debate_event::GoToClaim& go_to_claim() const;
  PROTOBUF_NODISCARD ::debate_event::GoToClaim* release_go_to_claim();
  ::debate_event::GoToClaim* mutable_go_to_claim();
  void set_allocated_go_to_claim(::debate_event::GoToClaim* value);
  void unsafe_arena_set_allocated_go_to_claim(::debate_event::GoToClaim* value);
  ::debate_event::GoToClaim* unsafe_arena_release_go_to_claim();

  private:
  const ::debate_event::GoToClaim& _internal_go_to_claim() const;
  ::debate_event::GoToClaim* _internal_mutable_go_to_claim();

  public:
  // .debate_event.DeleteChildClaim delete_child_claim = 23 [json_name = "deleteChildClaim"];
  bool has_delete_child_claim() const;
  private:
  bool _internal_has_delete_child_claim() const;

  public:
  void clear_delete_child_claim() ;
  const ::debate_event::DeleteChildClaim& delete_child_claim() const;
  PROTOBUF_NODISCARD ::debate_event::DeleteChildClaim* release_delete_child_claim();
  ::debate_event::DeleteChildClaim* mutable_delete_child_claim();
  void set_allocated_delete_child_claim(::debate_event::DeleteChildClaim* value);
  void unsafe_arena_set_allocated_delete_child_claim(::debate_event::DeleteChildClaim* value);
  ::debate_event::DeleteChildClaim* unsafe_arena_release_delete_child_claim();

  private:
  const ::debate_event::DeleteChildClaim& _internal_delete_child_claim() const;
  ::debate_event::DeleteChildClaim* _internal_mutable_delete_child_claim();

  public:
  // .debate_event.SubmitEditClaimDescription submit_edit_claim_description = 25 [json_name = "submitEditClaimDescription"];
  bool has_submit_edit_claim_description() const;
  private:
  bool _internal_has_submit_edit_claim_description() const;

  public:
  void clear_submit_edit_claim_description() ;
  const ::debate_event::SubmitEditClaimDescription& submit_edit_claim_description() const;
  PROTOBUF_NODISCARD ::debate_event::SubmitEditClaimDescription* release_submit_edit_claim_description();
  ::debate_event::SubmitEditClaimDescription* mutable_submit_edit_claim_description();
  void set_allocated_submit_edit_claim_description(::debate_event::SubmitEditClaimDescription* value);
  void unsafe_arena_set_allocated_submit_edit_claim_description(::debate_event::SubmitEditClaimDescription* value);
  ::debate_event::SubmitEditClaimDescription* unsafe_arena_release_submit_edit_claim_description();

  private:
  const ::debate_event::SubmitEditClaimDescription& _internal_submit_edit_claim_description() const;
  ::debate_event::SubmitEditClaimDescription* _internal_mutable_submit_edit_claim_description();

  public:
  // .debate_event.SubmitEditClaim submit_edit_claim = 28 [json_name = "submitEditClaim"];
  bool has_submit_edit_claim() const;
  private:
  bool _internal_has_submit_edit_claim() const;

  public:
  void clear_submit_edit_claim() ;
  const ::debate_event::SubmitEditClaim& submit_edit_claim() const;
  PROTOBUF_NODISCARD ::debate_event::SubmitEditClaim* release_submit_edit_claim();
  ::debate_event::SubmitEditClaim* mutable_submit_edit_claim();
  void set_allocated_submit_edit_claim(::debate_event::SubmitEditClaim* value);
  void unsafe_arena_set_allocated_submit_edit_claim(::debate_event::SubmitEditClaim* value);
  ::debate_event::SubmitEditClaim* unsafe_arena_release_submit_edit_claim();

  private:
  const ::debate_event::SubmitEditClaim& _internal_submit_edit_claim() const;
  ::debate_event::SubmitEditClaim* _internal_mutable_submit_edit_claim();

  public:
  // .debate_event.ConnectFromClaim connect_from_claim = 30 [json_name = "connectFromClaim"];
  bool has_connect_from_claim() const;
  private:
  bool _internal_has_connect_from_claim() const;

  public:
  void clear_connect_from_claim() ;
  const ::debate_event::ConnectFromClaim& connect_from_claim() const;
  PROTOBUF_NODISCARD ::debate_event::ConnectFromClaim* release_connect_from_claim();
  ::debate_event::ConnectFromClaim* mutable_connect_from_claim();
  void set_allocated_connect_from_claim(::debate_event::ConnectFromClaim* value);
  void unsafe_arena_set_allocated_connect_from_claim(::debate_event::ConnectFromClaim* value);
  ::debate_event::ConnectFromClaim* unsafe_arena_release_connect_from_claim();

  private:
  const ::debate_event::ConnectFromClaim& _internal_connect_from_claim() const;
  ::debate_event::ConnectFromClaim* _internal_mutable_connect_from_claim();

  public:
  // .debate_event.ConnectToClaim connect_to_claim = 31 [json_name = "connectToClaim"];
  bool has_connect_to_claim() const;
  private:
  bool _internal_has_connect_to_claim() const;

  public:
  void clear_connect_to_claim() ;
  const ::debate_event::ConnectToClaim& connect_to_claim() const;
  PROTOBUF_NODISCARD ::debate_event::ConnectToClaim* release_connect_to_claim();
  ::debate_event::ConnectToClaim* mutable_connect_to_claim();
  void set_allocated_connect_to_claim(::debate_event::ConnectToClaim* value);
  void unsafe_arena_set_allocated_connect_to_claim(::debate_event::ConnectToClaim* value);
  ::debate_event::ConnectToClaim* unsafe_arena_release_connect_to_claim();

  private:
  const ::debate_event::ConnectToClaim& _internal_connect_to_claim() const;
  ::debate_event::ConnectToClaim* _internal_mutable_connect_to_claim();

  public:
  // .debate_event.SubmitConnectClaims submit_connect_claims = 32 [json_name = "submitConnectClaims"];
  bool has_submit_connect_claims() const;
  private:
  bool _internal_has_submit_connect_claims() const;

  public:
  void clear_submit_connect_claims() ;
  const ::debate_event::SubmitConnectClaims& submit_connect_claims() const;
  PROTOBUF_NODISCARD ::debate_event::SubmitConnectClaims* release_submit_connect_claims();
  ::debate_event::SubmitConnectClaims* mutable_submit_connect_claims();
  void set_allocated_submit_connect_claims(::debate_event::SubmitConnectClaims* value);
  void unsafe_arena_set_allocated_submit_connect_claims(::debate_event::SubmitConnectClaims* value);
  ::debate_event::SubmitConnectClaims* unsafe_arena_release_submit_connect_claims();

  private:
  const ::debate_event::SubmitConnectClaims& _internal_submit_connect_claims() const;
  ::debate_event::SubmitConnectClaims* _internal_mutable_submit_connect_claims();

  public:
  // .debate_event.DeleteLink delete_link = 34 [json_name = "deleteLink"];
  bool has_delete_link() const;
  private:
  bool _internal_has_delete_link() const;

  public:
  void clear_delete_link() ;
  const ::debate_event::DeleteLink& delete_link() const;
  PROTOBUF_NODISCARD ::debate_event::DeleteLink* release_delete_link();
  ::debate_event::DeleteLink* mutable_delete_link();
  void set_allocated_delete_link(::debate_event::DeleteLink* value);
  void unsafe_arena_set_allocated_delete_link(::debate_event::DeleteLink* value);
  ::debate_event::DeleteLink* unsafe_arena_release_delete_link();

  private:
  const ::debate_event::DeleteLink& _internal_delete_link() const;
  ::debate_event::DeleteLink* _internal_mutable_delete_link();

  public:
  // .debate_event.JoinDebate join_debate = 35 [json_name = "joinDebate"];
  bool has_join_debate() const;
  private:
  bool _internal_has_join_debate() const;

  public:
  void clear_join_debate() ;
  const ::debate_event::JoinDebate& join_debate() const;
  PROTOBUF_NODISCARD ::debate_event::JoinDebate* release_join_debate();
  ::debate_event::JoinDebate* mutable_join_debate();
  void set_allocated_join_debate(::debate_event::JoinDebate* value);
  void unsafe_arena_set_allocated_join_debate(::debate_event::JoinDebate* value);
  ::debate_event::JoinDebate* unsafe_arena_release_join_debate();

  private:
  const ::debate_event::JoinDebate& _internal_join_debate() const;
  ::debate_event::JoinDebate* _internal_mutable_join_debate();

  public:
  // .debate_event.Login login = 36 [json_name = "login"];
  bool has_login() const;
  private:
  bool _internal_has_login() const;

  public:
  void clear_login() ;
  const ::debate_event::Login& login() const;
  PROTOBUF_NODISCARD ::debate_event::Login* release_login();
  ::debate_event::Login* mutable_login();
  void set_allocated_login(::debate_event::Login* value);
  void unsafe_arena_set_allocated_login(::debate_event::Login* value);
  ::debate_event::Login* unsafe_arena_release_login();

  private:
  const ::debate_event::Login& _internal_login() const;
  ::debate_event::Login* _internal_mutable_login();

  public:
  // .debate_event.AddClaimToBeChallenged add_claim_to_be_challenged = 38 [json_name = "addClaimToBeChallenged"];
  bool has_add_claim_to_be_challenged() const;
  private:
  bool _internal_has_add_claim_to_be_challenged() const;

  public:
  void clear_add_claim_to_be_challenged() ;
  const ::debate_event::AddClaimToBeChallenged& add_claim_to_be_challenged() const;
  PROTOBUF_NODISCARD ::debate_event::AddClaimToBeChallenged* release_add_claim_to_be_challenged();
  ::debate_event::AddClaimToBeChallenged* mutable_add_claim_to_be_challenged();
  void set_allocated_add_claim_to_be_challenged(::debate_event::AddClaimToBeChallenged* value);
  void unsafe_arena_set_allocated_add_claim_to_be_challenged(::debate_event::AddClaimToBeChallenged* value);
  ::debate_event::AddClaimToBeChallenged* unsafe_arena_release_add_claim_to_be_challenged();

  private:
  const ::debate_event::AddClaimToBeChallenged& _internal_add_claim_to_be_challenged() const;
  ::debate_event::AddClaimToBeChallenged* _internal_mutable_add_claim_to_be_challenged();

  public:
  // .debate_event.AddLinkToBeChallenged add_link_to_be_challenged = 39 [json_name = "addLinkToBeChallenged"];
  bool has_add_link_to_be_challenged() const;
  private:
  bool _internal_has_add_link_to_be_challenged() const;

  public:
  void clear_add_link_to_be_challenged() ;
  const ::debate_event::AddLinkToBeChallenged& add_link_to_be_challenged() const;
  PROTOBUF_NODISCARD ::debate_event::AddLinkToBeChallenged* release_add_link_to_be_challenged();
  ::debate_event::AddLinkToBeChallenged* mutable_add_link_to_be_challenged();
  void set_allocated_add_link_to_be_challenged(::debate_event::AddLinkToBeChallenged* value);
  void unsafe_arena_set_allocated_add_link_to_be_challenged(::debate_event::AddLinkToBeChallenged* value);
  ::debate_event::AddLinkToBeChallenged* unsafe_arena_release_add_link_to_be_challenged();

  private:
  const ::debate_event::AddLinkToBeChallenged& _internal_add_link_to_be_challenged() const;
  ::debate_event::AddLinkToBeChallenged* _internal_mutable_add_link_to_be_challenged();

  public:
  // .debate_event.SubmitChallengeClaim submit_challenge_claim = 40 [json_name = "submitChallengeClaim"];
  bool has_submit_challenge_claim() const;
  private:
  bool _internal_has_submit_challenge_claim() const;

  public:
  void clear_submit_challenge_claim() ;
  const ::debate_event::SubmitChallengeClaim& submit_challenge_claim() const;
  PROTOBUF_NODISCARD ::debate_event::SubmitChallengeClaim* release_submit_challenge_claim();
  ::debate_event::SubmitChallengeClaim* mutable_submit_challenge_claim();
  void set_allocated_submit_challenge_claim(::debate_event::SubmitChallengeClaim* value);
  void unsafe_arena_set_allocated_submit_challenge_claim(::debate_event::SubmitChallengeClaim* value);
  ::debate_event::SubmitChallengeClaim* unsafe_arena_release_submit_challenge_claim();

  private:
  const ::debate_event::SubmitChallengeClaim& _internal_submit_challenge_claim() const;
  ::debate_event::SubmitChallengeClaim* _internal_mutable_submit_challenge_claim();

  public:
  // .debate_event.GoToChallenge go_to_challenge = 41 [json_name = "goToChallenge"];
  bool has_go_to_challenge() const;
  private:
  bool _internal_has_go_to_challenge() const;

  public:
  void clear_go_to_challenge() ;
  const ::debate_event::GoToChallenge& go_to_challenge() const;
  PROTOBUF_NODISCARD ::debate_event::GoToChallenge* release_go_to_challenge();
  ::debate_event::GoToChallenge* mutable_go_to_challenge();
  void set_allocated_go_to_challenge(::debate_event::GoToChallenge* value);
  void unsafe_arena_set_allocated_go_to_challenge(::debate_event::GoToChallenge* value);
  ::debate_event::GoToChallenge* unsafe_arena_release_go_to_challenge();

  private:
  const ::debate_event::GoToChallenge& _internal_go_to_challenge() const;
  ::debate_event::GoToChallenge* _internal_mutable_go_to_challenge();

  public:
  // .debate_event.ConcedeChallenge concede_challenge = 42 [json_name = "concedeChallenge"];
  bool has_concede_challenge() const;
  private:
  bool _internal_has_concede_challenge() const;

  public:
  void clear_concede_challenge() ;
  const ::debate_event::ConcedeChallenge& concede_challenge() const;
  PROTOBUF_NODISCARD ::debate_event::ConcedeChallenge* release_concede_challenge();
  ::debate_event::ConcedeChallenge* mutable_concede_challenge();
  void set_allocated_concede_challenge(::debate_event::ConcedeChallenge* value);
  void unsafe_arena_set_allocated_concede_challenge(::debate_event::ConcedeChallenge* value);
  ::debate_event::ConcedeChallenge* unsafe_arena_release_concede_challenge();

  private:
  const ::debate_event::ConcedeChallenge& _internal_concede_challenge() const;
  ::debate_event::ConcedeChallenge* _internal_mutable_concede_challenge();

  public:
  // .debate_event.RemoveClaimToBeChallenged remove_claim_to_be_challenged = 46 [json_name = "removeClaimToBeChallenged"];
  bool has_remove_claim_to_be_challenged() const;
  private:
  bool _internal_has_remove_claim_to_be_challenged() const;

  public:
  void clear_remove_claim_to_be_challenged() ;
  const ::debate_event::RemoveClaimToBeChallenged& remove_claim_to_be_challenged() const;
  PROTOBUF_NODISCARD ::debate_event::RemoveClaimToBeChallenged* release_remove_claim_to_be_challenged();
  ::debate_event::RemoveClaimToBeChallenged* mutable_remove_claim_to_be_challenged();
  void set_allocated_remove_claim_to_be_challenged(::debate_event::RemoveClaimToBeChallenged* value);
  void unsafe_arena_set_allocated_remove_claim_to_be_challenged(::debate_event::RemoveClaimToBeChallenged* value);
  ::debate_event::RemoveClaimToBeChallenged* unsafe_arena_release_remove_claim_to_be_challenged();

  private:
  const ::debate_event::RemoveClaimToBeChallenged& _internal_remove_claim_to_be_challenged() const;
  ::debate_event::RemoveClaimToBeChallenged* _internal_mutable_remove_claim_to_be_challenged();

  public:
  // .debate_event.RemoveLinkToBeChallenged remove_link_to_be_challenged = 47 [json_name = "removeLinkToBeChallenged"];
  bool has_remove_link_to_be_challenged() const;
  private:
  bool _internal_has_remove_link_to_be_challenged() const;

  public:
  void clear_remove_link_to_be_challenged() ;
  const ::debate_event::RemoveLinkToBeChallenged& remove_link_to_be_challenged() const;
  PROTOBUF_NODISCARD ::debate_event::RemoveLinkToBeChallenged* release_remove_link_to_be_challenged();
  ::debate_event::RemoveLinkToBeChallenged* mutable_remove_link_to_be_challenged();
  void set_allocated_remove_link_to_be_challenged(::debate_event::RemoveLinkToBeChallenged* value);
  void unsafe_arena_set_allocated_remove_link_to_be_challenged(::debate_event::RemoveLinkToBeChallenged* value);
  ::debate_event::RemoveLinkToBeChallenged* unsafe_arena_release_remove_link_to_be_challenged();

  private:
  const ::debate_event::RemoveLinkToBeChallenged& _internal_remove_link_to_be_challenged() const;
  ::debate_event::RemoveLinkToBeChallenged* _internal_mutable_remove_link_to_be_challenged();

  public:
  // .debate_event.DeleteChallenge delete_challenge = 48 [json_name = "deleteChallenge"];
  bool has_delete_challenge() const;
  private:
  bool _internal_has_delete_challenge() const;

  public:
  void clear_delete_challenge() ;
  const ::debate_event::DeleteChallenge& delete_challenge() const;
  PROTOBUF_NODISCARD ::debate_event::DeleteChallenge* release_delete_challenge();
  ::debate_event::DeleteChallenge* mutable_delete_challenge();
  void set_allocated_delete_challenge(::debate_event::DeleteChallenge* value);
  void unsafe_arena_set_allocated_delete_challenge(::debate_event::DeleteChallenge* value);
  ::debate_event::DeleteChallenge* unsafe_arena_release_delete_challenge();

  private:
  const ::debate_event::DeleteChallenge& _internal_delete_challenge() const;
  ::debate_event::DeleteChallenge* _internal_mutable_delete_challenge();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:debate_event.DebateEvent)
 private:
  class _Internal;
  void set_has_create_debate();
  void set_has_delete_debate();
  void set_has_enter_debate();
  void set_has_add_child_claim();
  void set_has_go_to_claim();
  void set_has_delete_child_claim();
  void set_has_submit_edit_claim_description();
  void set_has_submit_edit_claim();
  void set_has_connect_from_claim();
  void set_has_connect_to_claim();
  void set_has_submit_connect_claims();
  void set_has_delete_link();
  void set_has_join_debate();
  void set_has_login();
  void set_has_add_claim_to_be_challenged();
  void set_has_add_link_to_be_challenged();
  void set_has_submit_challenge_claim();
  void set_has_go_to_challenge();
  void set_has_concede_challenge();
  void set_has_remove_claim_to_be_challenged();
  void set_has_remove_link_to_be_challenged();
  void set_has_delete_challenge();
  inline bool has_payload() const;
  inline void clear_has_payload();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 25, 24,
      0, 7>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DebateEvent& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::debate_event::UserAuthInfo* user_;
    ::google::protobuf::Timestamp* occurred_at_;
    int type_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::debate_event::CreateDebate* create_debate_;
      ::debate_event::DeleteDebate* delete_debate_;
      ::debate_event::EnterDebate* enter_debate_;
      ::debate_event::AddChildClaim* add_child_claim_;
      ::debate_event::GoToClaim* go_to_claim_;
      ::debate_event::DeleteChildClaim* delete_child_claim_;
      ::debate_event::SubmitEditClaimDescription* submit_edit_claim_description_;
      ::debate_event::SubmitEditClaim* submit_edit_claim_;
      ::debate_event::ConnectFromClaim* connect_from_claim_;
      ::debate_event::ConnectToClaim* connect_to_claim_;
      ::debate_event::SubmitConnectClaims* submit_connect_claims_;
      ::debate_event::DeleteLink* delete_link_;
      ::debate_event::JoinDebate* join_debate_;
      ::debate_event::Login* login_;
      ::debate_event::AddClaimToBeChallenged* add_claim_to_be_challenged_;
      ::debate_event::AddLinkToBeChallenged* add_link_to_be_challenged_;
      ::debate_event::SubmitChallengeClaim* submit_challenge_claim_;
      ::debate_event::GoToChallenge* go_to_challenge_;
      ::debate_event::ConcedeChallenge* concede_challenge_;
      ::debate_event::RemoveClaimToBeChallenged* remove_claim_to_be_challenged_;
      ::debate_event::RemoveLinkToBeChallenged* remove_link_to_be_challenged_;
      ::debate_event::DeleteChallenge* delete_challenge_;
    } payload_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_debate_5fevent_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CreateDebate

// string debate_topic = 2 [json_name = "debateTopic"];
inline void CreateDebate::clear_debate_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_topic_.ClearToEmpty();
}
inline const std::string& CreateDebate::debate_topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.CreateDebate.debate_topic)
  return _internal_debate_topic();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateDebate::set_debate_topic(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.CreateDebate.debate_topic)
}
inline std::string* CreateDebate::mutable_debate_topic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_debate_topic();
  // @@protoc_insertion_point(field_mutable:debate_event.CreateDebate.debate_topic)
  return _s;
}
inline const std::string& CreateDebate::_internal_debate_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_topic_.Get();
}
inline void CreateDebate::_internal_set_debate_topic(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_topic_.Set(value, GetArena());
}
inline std::string* CreateDebate::_internal_mutable_debate_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.debate_topic_.Mutable( GetArena());
}
inline std::string* CreateDebate::release_debate_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.CreateDebate.debate_topic)
  return _impl_.debate_topic_.Release();
}
inline void CreateDebate::set_allocated_debate_topic(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_topic_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.debate_topic_.IsDefault()) {
    _impl_.debate_topic_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.CreateDebate.debate_topic)
}

// -------------------------------------------------------------------

// DeleteDebate

// int32 debate_id = 1 [json_name = "debateId"];
inline void DeleteDebate::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_ = 0;
}
inline ::int32_t DeleteDebate::debate_id() const {
  // @@protoc_insertion_point(field_get:debate_event.DeleteDebate.debate_id)
  return _internal_debate_id();
}
inline void DeleteDebate::set_debate_id(::int32_t value) {
  _internal_set_debate_id(value);
  // @@protoc_insertion_point(field_set:debate_event.DeleteDebate.debate_id)
}
inline ::int32_t DeleteDebate::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_;
}
inline void DeleteDebate::_internal_set_debate_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_ = value;
}

// -------------------------------------------------------------------

// EnterDebate

// int32 debate_id = 1 [json_name = "debateId"];
inline void EnterDebate::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_ = 0;
}
inline ::int32_t EnterDebate::debate_id() const {
  // @@protoc_insertion_point(field_get:debate_event.EnterDebate.debate_id)
  return _internal_debate_id();
}
inline void EnterDebate::set_debate_id(::int32_t value) {
  _internal_set_debate_id(value);
  // @@protoc_insertion_point(field_set:debate_event.EnterDebate.debate_id)
}
inline ::int32_t EnterDebate::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_;
}
inline void EnterDebate::_internal_set_debate_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_ = value;
}

// -------------------------------------------------------------------

// AddChildClaim

// string claim = 1 [json_name = "claim"];
inline void AddChildClaim::clear_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_.ClearToEmpty();
}
inline const std::string& AddChildClaim::claim() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.AddChildClaim.claim)
  return _internal_claim();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddChildClaim::set_claim(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.AddChildClaim.claim)
}
inline std::string* AddChildClaim::mutable_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.AddChildClaim.claim)
  return _s;
}
inline const std::string& AddChildClaim::_internal_claim() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.claim_.Get();
}
inline void AddChildClaim::_internal_set_claim(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_.Set(value, GetArena());
}
inline std::string* AddChildClaim::_internal_mutable_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.claim_.Mutable( GetArena());
}
inline std::string* AddChildClaim::release_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.AddChildClaim.claim)
  return _impl_.claim_.Release();
}
inline void AddChildClaim::set_allocated_claim(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.claim_.IsDefault()) {
    _impl_.claim_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.AddChildClaim.claim)
}

// string description = 2 [json_name = "description"];
inline void AddChildClaim::clear_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& AddChildClaim::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.AddChildClaim.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddChildClaim::set_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.AddChildClaim.description)
}
inline std::string* AddChildClaim::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:debate_event.AddChildClaim.description)
  return _s;
}
inline const std::string& AddChildClaim::_internal_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.description_.Get();
}
inline void AddChildClaim::_internal_set_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* AddChildClaim::_internal_mutable_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* AddChildClaim::release_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.AddChildClaim.description)
  return _impl_.description_.Release();
}
inline void AddChildClaim::set_allocated_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.AddChildClaim.description)
}

// -------------------------------------------------------------------

// DeleteChildClaim

// int32 claim_id = 2 [json_name = "claimId"];
inline void DeleteChildClaim::clear_claim_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_id_ = 0;
}
inline ::int32_t DeleteChildClaim::claim_id() const {
  // @@protoc_insertion_point(field_get:debate_event.DeleteChildClaim.claim_id)
  return _internal_claim_id();
}
inline void DeleteChildClaim::set_claim_id(::int32_t value) {
  _internal_set_claim_id(value);
  // @@protoc_insertion_point(field_set:debate_event.DeleteChildClaim.claim_id)
}
inline ::int32_t DeleteChildClaim::_internal_claim_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.claim_id_;
}
inline void DeleteChildClaim::_internal_set_claim_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_id_ = value;
}

// -------------------------------------------------------------------

// AddConnection

// int32 debate_id = 2 [json_name = "debateId"];
inline void AddConnection::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_ = 0;
}
inline ::int32_t AddConnection::debate_id() const {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.debate_id)
  return _internal_debate_id();
}
inline void AddConnection::set_debate_id(::int32_t value) {
  _internal_set_debate_id(value);
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.debate_id)
}
inline ::int32_t AddConnection::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_;
}
inline void AddConnection::_internal_set_debate_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_ = value;
}

// int32 from_id = 3 [json_name = "fromId"];
inline void AddConnection::clear_from_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_id_ = 0;
}
inline ::int32_t AddConnection::from_id() const {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.from_id)
  return _internal_from_id();
}
inline void AddConnection::set_from_id(::int32_t value) {
  _internal_set_from_id(value);
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.from_id)
}
inline ::int32_t AddConnection::_internal_from_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_id_;
}
inline void AddConnection::_internal_set_from_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_id_ = value;
}

// int32 to_id = 4 [json_name = "toId"];
inline void AddConnection::clear_to_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_id_ = 0;
}
inline ::int32_t AddConnection::to_id() const {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.to_id)
  return _internal_to_id();
}
inline void AddConnection::set_to_id(::int32_t value) {
  _internal_set_to_id(value);
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.to_id)
}
inline ::int32_t AddConnection::_internal_to_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_id_;
}
inline void AddConnection::_internal_set_to_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_id_ = value;
}

// string connection = 5 [json_name = "connection"];
inline void AddConnection::clear_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.ClearToEmpty();
}
inline const std::string& AddConnection::connection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.AddConnection.connection)
  return _internal_connection();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddConnection::set_connection(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.AddConnection.connection)
}
inline std::string* AddConnection::mutable_connection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connection();
  // @@protoc_insertion_point(field_mutable:debate_event.AddConnection.connection)
  return _s;
}
inline const std::string& AddConnection::_internal_connection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_.Get();
}
inline void AddConnection::_internal_set_connection(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.Set(value, GetArena());
}
inline std::string* AddConnection::_internal_mutable_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connection_.Mutable( GetArena());
}
inline std::string* AddConnection::release_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.AddConnection.connection)
  return _impl_.connection_.Release();
}
inline void AddConnection::set_allocated_connection(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connection_.IsDefault()) {
    _impl_.connection_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.AddConnection.connection)
}

// -------------------------------------------------------------------

// GoToClaim

// int32 claim_id = 2 [json_name = "claimId"];
inline void GoToClaim::clear_claim_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_id_ = 0;
}
inline ::int32_t GoToClaim::claim_id() const {
  // @@protoc_insertion_point(field_get:debate_event.GoToClaim.claim_id)
  return _internal_claim_id();
}
inline void GoToClaim::set_claim_id(::int32_t value) {
  _internal_set_claim_id(value);
  // @@protoc_insertion_point(field_set:debate_event.GoToClaim.claim_id)
}
inline ::int32_t GoToClaim::_internal_claim_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.claim_id_;
}
inline void GoToClaim::_internal_set_claim_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_id_ = value;
}

// -------------------------------------------------------------------

// SubmitEditClaimDescription

// string new_description = 1 [json_name = "newDescription"];
inline void SubmitEditClaimDescription::clear_new_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_description_.ClearToEmpty();
}
inline const std::string& SubmitEditClaimDescription::new_description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.SubmitEditClaimDescription.new_description)
  return _internal_new_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubmitEditClaimDescription::set_new_description(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_description_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.SubmitEditClaimDescription.new_description)
}
inline std::string* SubmitEditClaimDescription::mutable_new_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_description();
  // @@protoc_insertion_point(field_mutable:debate_event.SubmitEditClaimDescription.new_description)
  return _s;
}
inline const std::string& SubmitEditClaimDescription::_internal_new_description() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_description_.Get();
}
inline void SubmitEditClaimDescription::_internal_set_new_description(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_description_.Set(value, GetArena());
}
inline std::string* SubmitEditClaimDescription::_internal_mutable_new_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_description_.Mutable( GetArena());
}
inline std::string* SubmitEditClaimDescription::release_new_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.SubmitEditClaimDescription.new_description)
  return _impl_.new_description_.Release();
}
inline void SubmitEditClaimDescription::set_allocated_new_description(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_description_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.new_description_.IsDefault()) {
    _impl_.new_description_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.SubmitEditClaimDescription.new_description)
}

// -------------------------------------------------------------------

// SubmitEditClaim

// string new_claim = 1 [json_name = "newClaim"];
inline void SubmitEditClaim::clear_new_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_claim_.ClearToEmpty();
}
inline const std::string& SubmitEditClaim::new_claim() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.SubmitEditClaim.new_claim)
  return _internal_new_claim();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubmitEditClaim::set_new_claim(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_claim_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.SubmitEditClaim.new_claim)
}
inline std::string* SubmitEditClaim::mutable_new_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.SubmitEditClaim.new_claim)
  return _s;
}
inline const std::string& SubmitEditClaim::_internal_new_claim() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_claim_.Get();
}
inline void SubmitEditClaim::_internal_set_new_claim(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_claim_.Set(value, GetArena());
}
inline std::string* SubmitEditClaim::_internal_mutable_new_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_claim_.Mutable( GetArena());
}
inline std::string* SubmitEditClaim::release_new_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.SubmitEditClaim.new_claim)
  return _impl_.new_claim_.Release();
}
inline void SubmitEditClaim::set_allocated_new_claim(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_claim_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.new_claim_.IsDefault()) {
    _impl_.new_claim_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.SubmitEditClaim.new_claim)
}

// -------------------------------------------------------------------

// ConnectFromClaim

// int32 from_claim_id = 1 [json_name = "fromClaimId"];
inline void ConnectFromClaim::clear_from_claim_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_claim_id_ = 0;
}
inline ::int32_t ConnectFromClaim::from_claim_id() const {
  // @@protoc_insertion_point(field_get:debate_event.ConnectFromClaim.from_claim_id)
  return _internal_from_claim_id();
}
inline void ConnectFromClaim::set_from_claim_id(::int32_t value) {
  _internal_set_from_claim_id(value);
  // @@protoc_insertion_point(field_set:debate_event.ConnectFromClaim.from_claim_id)
}
inline ::int32_t ConnectFromClaim::_internal_from_claim_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_claim_id_;
}
inline void ConnectFromClaim::_internal_set_from_claim_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_claim_id_ = value;
}

// -------------------------------------------------------------------

// ConnectToClaim

// int32 to_claim_id = 2 [json_name = "toClaimId"];
inline void ConnectToClaim::clear_to_claim_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_claim_id_ = 0;
}
inline ::int32_t ConnectToClaim::to_claim_id() const {
  // @@protoc_insertion_point(field_get:debate_event.ConnectToClaim.to_claim_id)
  return _internal_to_claim_id();
}
inline void ConnectToClaim::set_to_claim_id(::int32_t value) {
  _internal_set_to_claim_id(value);
  // @@protoc_insertion_point(field_set:debate_event.ConnectToClaim.to_claim_id)
}
inline ::int32_t ConnectToClaim::_internal_to_claim_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_claim_id_;
}
inline void ConnectToClaim::_internal_set_to_claim_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_claim_id_ = value;
}

// -------------------------------------------------------------------

// SubmitConnectClaims

// string connection = 1 [json_name = "connection"];
inline void SubmitConnectClaims::clear_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.ClearToEmpty();
}
inline const std::string& SubmitConnectClaims::connection() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.SubmitConnectClaims.connection)
  return _internal_connection();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubmitConnectClaims::set_connection(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.SubmitConnectClaims.connection)
}
inline std::string* SubmitConnectClaims::mutable_connection() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_connection();
  // @@protoc_insertion_point(field_mutable:debate_event.SubmitConnectClaims.connection)
  return _s;
}
inline const std::string& SubmitConnectClaims::_internal_connection() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_.Get();
}
inline void SubmitConnectClaims::_internal_set_connection(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.Set(value, GetArena());
}
inline std::string* SubmitConnectClaims::_internal_mutable_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.connection_.Mutable( GetArena());
}
inline std::string* SubmitConnectClaims::release_connection() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.SubmitConnectClaims.connection)
  return _impl_.connection_.Release();
}
inline void SubmitConnectClaims::set_allocated_connection(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.connection_.IsDefault()) {
    _impl_.connection_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.SubmitConnectClaims.connection)
}

// int32 from_claim_id = 2 [json_name = "fromClaimId"];
inline void SubmitConnectClaims::clear_from_claim_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_claim_id_ = 0;
}
inline ::int32_t SubmitConnectClaims::from_claim_id() const {
  // @@protoc_insertion_point(field_get:debate_event.SubmitConnectClaims.from_claim_id)
  return _internal_from_claim_id();
}
inline void SubmitConnectClaims::set_from_claim_id(::int32_t value) {
  _internal_set_from_claim_id(value);
  // @@protoc_insertion_point(field_set:debate_event.SubmitConnectClaims.from_claim_id)
}
inline ::int32_t SubmitConnectClaims::_internal_from_claim_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_claim_id_;
}
inline void SubmitConnectClaims::_internal_set_from_claim_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_claim_id_ = value;
}

// int32 to_claim_id = 3 [json_name = "toClaimId"];
inline void SubmitConnectClaims::clear_to_claim_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_claim_id_ = 0;
}
inline ::int32_t SubmitConnectClaims::to_claim_id() const {
  // @@protoc_insertion_point(field_get:debate_event.SubmitConnectClaims.to_claim_id)
  return _internal_to_claim_id();
}
inline void SubmitConnectClaims::set_to_claim_id(::int32_t value) {
  _internal_set_to_claim_id(value);
  // @@protoc_insertion_point(field_set:debate_event.SubmitConnectClaims.to_claim_id)
}
inline ::int32_t SubmitConnectClaims::_internal_to_claim_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.to_claim_id_;
}
inline void SubmitConnectClaims::_internal_set_to_claim_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.to_claim_id_ = value;
}

// -------------------------------------------------------------------

// DeleteLink

// int32 link_id = 1 [json_name = "linkId"];
inline void DeleteLink::clear_link_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.link_id_ = 0;
}
inline ::int32_t DeleteLink::link_id() const {
  // @@protoc_insertion_point(field_get:debate_event.DeleteLink.link_id)
  return _internal_link_id();
}
inline void DeleteLink::set_link_id(::int32_t value) {
  _internal_set_link_id(value);
  // @@protoc_insertion_point(field_set:debate_event.DeleteLink.link_id)
}
inline ::int32_t DeleteLink::_internal_link_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.link_id_;
}
inline void DeleteLink::_internal_set_link_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.link_id_ = value;
}

// -------------------------------------------------------------------

// JoinDebate

// int32 debate_id = 1 [json_name = "debateId"];
inline void JoinDebate::clear_debate_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_ = 0;
}
inline ::int32_t JoinDebate::debate_id() const {
  // @@protoc_insertion_point(field_get:debate_event.JoinDebate.debate_id)
  return _internal_debate_id();
}
inline void JoinDebate::set_debate_id(::int32_t value) {
  _internal_set_debate_id(value);
  // @@protoc_insertion_point(field_set:debate_event.JoinDebate.debate_id)
}
inline ::int32_t JoinDebate::_internal_debate_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.debate_id_;
}
inline void JoinDebate::_internal_set_debate_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.debate_id_ = value;
}

// -------------------------------------------------------------------

// Login

// string username = 1 [json_name = "username"];
inline void Login::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& Login::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.Login.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Login::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.Login.username)
}
inline std::string* Login::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:debate_event.Login.username)
  return _s;
}
inline const std::string& Login::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void Login::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* Login::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* Login::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.Login.username)
  return _impl_.username_.Release();
}
inline void Login::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.Login.username)
}

// string password = 2 [json_name = "password"];
inline void Login::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& Login::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.Login.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Login::set_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.Login.password)
}
inline std::string* Login::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:debate_event.Login.password)
  return _s;
}
inline const std::string& Login::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void Login::_internal_set_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.Set(value, GetArena());
}
inline std::string* Login::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* Login::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.Login.password)
  return _impl_.password_.Release();
}
inline void Login::set_allocated_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.Login.password)
}

// -------------------------------------------------------------------

// AddClaimToBeChallenged

// int32 claim_id = 1 [json_name = "claimId"];
inline void AddClaimToBeChallenged::clear_claim_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_id_ = 0;
}
inline ::int32_t AddClaimToBeChallenged::claim_id() const {
  // @@protoc_insertion_point(field_get:debate_event.AddClaimToBeChallenged.claim_id)
  return _internal_claim_id();
}
inline void AddClaimToBeChallenged::set_claim_id(::int32_t value) {
  _internal_set_claim_id(value);
  // @@protoc_insertion_point(field_set:debate_event.AddClaimToBeChallenged.claim_id)
}
inline ::int32_t AddClaimToBeChallenged::_internal_claim_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.claim_id_;
}
inline void AddClaimToBeChallenged::_internal_set_claim_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_id_ = value;
}

// -------------------------------------------------------------------

// RemoveClaimToBeChallenged

// int32 claim_id = 1 [json_name = "claimId"];
inline void RemoveClaimToBeChallenged::clear_claim_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_id_ = 0;
}
inline ::int32_t RemoveClaimToBeChallenged::claim_id() const {
  // @@protoc_insertion_point(field_get:debate_event.RemoveClaimToBeChallenged.claim_id)
  return _internal_claim_id();
}
inline void RemoveClaimToBeChallenged::set_claim_id(::int32_t value) {
  _internal_set_claim_id(value);
  // @@protoc_insertion_point(field_set:debate_event.RemoveClaimToBeChallenged.claim_id)
}
inline ::int32_t RemoveClaimToBeChallenged::_internal_claim_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.claim_id_;
}
inline void RemoveClaimToBeChallenged::_internal_set_claim_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.claim_id_ = value;
}

// -------------------------------------------------------------------

// AddLinkToBeChallenged

// int32 link_id = 1 [json_name = "linkId"];
inline void AddLinkToBeChallenged::clear_link_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.link_id_ = 0;
}
inline ::int32_t AddLinkToBeChallenged::link_id() const {
  // @@protoc_insertion_point(field_get:debate_event.AddLinkToBeChallenged.link_id)
  return _internal_link_id();
}
inline void AddLinkToBeChallenged::set_link_id(::int32_t value) {
  _internal_set_link_id(value);
  // @@protoc_insertion_point(field_set:debate_event.AddLinkToBeChallenged.link_id)
}
inline ::int32_t AddLinkToBeChallenged::_internal_link_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.link_id_;
}
inline void AddLinkToBeChallenged::_internal_set_link_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.link_id_ = value;
}

// -------------------------------------------------------------------

// RemoveLinkToBeChallenged

// int32 link_id = 1 [json_name = "linkId"];
inline void RemoveLinkToBeChallenged::clear_link_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.link_id_ = 0;
}
inline ::int32_t RemoveLinkToBeChallenged::link_id() const {
  // @@protoc_insertion_point(field_get:debate_event.RemoveLinkToBeChallenged.link_id)
  return _internal_link_id();
}
inline void RemoveLinkToBeChallenged::set_link_id(::int32_t value) {
  _internal_set_link_id(value);
  // @@protoc_insertion_point(field_set:debate_event.RemoveLinkToBeChallenged.link_id)
}
inline ::int32_t RemoveLinkToBeChallenged::_internal_link_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.link_id_;
}
inline void RemoveLinkToBeChallenged::_internal_set_link_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.link_id_ = value;
}

// -------------------------------------------------------------------

// SubmitChallengeClaim

// string challenge_sentence = 1 [json_name = "challengeSentence"];
inline void SubmitChallengeClaim::clear_challenge_sentence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_sentence_.ClearToEmpty();
}
inline const std::string& SubmitChallengeClaim::challenge_sentence() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.SubmitChallengeClaim.challenge_sentence)
  return _internal_challenge_sentence();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SubmitChallengeClaim::set_challenge_sentence(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_sentence_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.SubmitChallengeClaim.challenge_sentence)
}
inline std::string* SubmitChallengeClaim::mutable_challenge_sentence() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_challenge_sentence();
  // @@protoc_insertion_point(field_mutable:debate_event.SubmitChallengeClaim.challenge_sentence)
  return _s;
}
inline const std::string& SubmitChallengeClaim::_internal_challenge_sentence() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.challenge_sentence_.Get();
}
inline void SubmitChallengeClaim::_internal_set_challenge_sentence(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_sentence_.Set(value, GetArena());
}
inline std::string* SubmitChallengeClaim::_internal_mutable_challenge_sentence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.challenge_sentence_.Mutable( GetArena());
}
inline std::string* SubmitChallengeClaim::release_challenge_sentence() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.SubmitChallengeClaim.challenge_sentence)
  return _impl_.challenge_sentence_.Release();
}
inline void SubmitChallengeClaim::set_allocated_challenge_sentence(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_sentence_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.challenge_sentence_.IsDefault()) {
    _impl_.challenge_sentence_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.SubmitChallengeClaim.challenge_sentence)
}

// -------------------------------------------------------------------

// GoToChallenge

// int32 challenge_id = 1 [json_name = "challengeId"];
inline void GoToChallenge::clear_challenge_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_id_ = 0;
}
inline ::int32_t GoToChallenge::challenge_id() const {
  // @@protoc_insertion_point(field_get:debate_event.GoToChallenge.challenge_id)
  return _internal_challenge_id();
}
inline void GoToChallenge::set_challenge_id(::int32_t value) {
  _internal_set_challenge_id(value);
  // @@protoc_insertion_point(field_set:debate_event.GoToChallenge.challenge_id)
}
inline ::int32_t GoToChallenge::_internal_challenge_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.challenge_id_;
}
inline void GoToChallenge::_internal_set_challenge_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_id_ = value;
}

// -------------------------------------------------------------------

// ConcedeChallenge

// int32 challenge_id = 1 [json_name = "challengeId"];
inline void ConcedeChallenge::clear_challenge_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_id_ = 0;
}
inline ::int32_t ConcedeChallenge::challenge_id() const {
  // @@protoc_insertion_point(field_get:debate_event.ConcedeChallenge.challenge_id)
  return _internal_challenge_id();
}
inline void ConcedeChallenge::set_challenge_id(::int32_t value) {
  _internal_set_challenge_id(value);
  // @@protoc_insertion_point(field_set:debate_event.ConcedeChallenge.challenge_id)
}
inline ::int32_t ConcedeChallenge::_internal_challenge_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.challenge_id_;
}
inline void ConcedeChallenge::_internal_set_challenge_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_id_ = value;
}

// -------------------------------------------------------------------

// DeleteChallenge

// int32 challenge_id = 1 [json_name = "challengeId"];
inline void DeleteChallenge::clear_challenge_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_id_ = 0;
}
inline ::int32_t DeleteChallenge::challenge_id() const {
  // @@protoc_insertion_point(field_get:debate_event.DeleteChallenge.challenge_id)
  return _internal_challenge_id();
}
inline void DeleteChallenge::set_challenge_id(::int32_t value) {
  _internal_set_challenge_id(value);
  // @@protoc_insertion_point(field_set:debate_event.DeleteChallenge.challenge_id)
}
inline ::int32_t DeleteChallenge::_internal_challenge_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.challenge_id_;
}
inline void DeleteChallenge::_internal_set_challenge_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.challenge_id_ = value;
}

// -------------------------------------------------------------------

// UserAuthInfo

// string username = 1 [json_name = "username"];
inline void UserAuthInfo::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserAuthInfo::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.UserAuthInfo.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserAuthInfo::set_username(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:debate_event.UserAuthInfo.username)
}
inline std::string* UserAuthInfo::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:debate_event.UserAuthInfo.username)
  return _s;
}
inline const std::string& UserAuthInfo::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void UserAuthInfo::_internal_set_username(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.Set(value, GetArena());
}
inline std::string* UserAuthInfo::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* UserAuthInfo::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.UserAuthInfo.username)
  return _impl_.username_.Release();
}
inline void UserAuthInfo::set_allocated_username(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:debate_event.UserAuthInfo.username)
}

// int32 user_id = 2 [json_name = "userId"];
inline void UserAuthInfo::clear_user_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = 0;
}
inline ::int32_t UserAuthInfo::user_id() const {
  // @@protoc_insertion_point(field_get:debate_event.UserAuthInfo.user_id)
  return _internal_user_id();
}
inline void UserAuthInfo::set_user_id(::int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:debate_event.UserAuthInfo.user_id)
}
inline ::int32_t UserAuthInfo::_internal_user_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.user_id_;
}
inline void UserAuthInfo::_internal_set_user_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.user_id_ = value;
}

// bool is_logged_in = 3 [json_name = "isLoggedIn"];
inline void UserAuthInfo::clear_is_logged_in() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_logged_in_ = false;
}
inline bool UserAuthInfo::is_logged_in() const {
  // @@protoc_insertion_point(field_get:debate_event.UserAuthInfo.is_logged_in)
  return _internal_is_logged_in();
}
inline void UserAuthInfo::set_is_logged_in(bool value) {
  _internal_set_is_logged_in(value);
  // @@protoc_insertion_point(field_set:debate_event.UserAuthInfo.is_logged_in)
}
inline bool UserAuthInfo::_internal_is_logged_in() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_logged_in_;
}
inline void UserAuthInfo::_internal_set_is_logged_in(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_logged_in_ = value;
}

// -------------------------------------------------------------------

// DebateEvent

// .debate_event.UserAuthInfo user = 1 [json_name = "user"];
inline bool DebateEvent::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_ != nullptr);
  return value;
}
inline void DebateEvent::clear_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ != nullptr) _impl_.user_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::debate_event::UserAuthInfo& DebateEvent::_internal_user() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::debate_event::UserAuthInfo* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::debate_event::UserAuthInfo&>(::debate_event::_UserAuthInfo_default_instance_);
}
inline const ::debate_event::UserAuthInfo& DebateEvent::user() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.user)
  return _internal_user();
}
inline void DebateEvent::unsafe_arena_set_allocated_user(::debate_event::UserAuthInfo* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = reinterpret_cast<::debate_event::UserAuthInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.user)
}
inline ::debate_event::UserAuthInfo* DebateEvent::release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debate_event::UserAuthInfo* released = _impl_.user_;
  _impl_.user_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::debate_event::UserAuthInfo* DebateEvent::unsafe_arena_release_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.user)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::debate_event::UserAuthInfo* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::debate_event::UserAuthInfo* DebateEvent::_internal_mutable_user() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.user_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::debate_event::UserAuthInfo>(GetArena());
    _impl_.user_ = reinterpret_cast<::debate_event::UserAuthInfo*>(p);
  }
  return _impl_.user_;
}
inline ::debate_event::UserAuthInfo* DebateEvent::mutable_user() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::debate_event::UserAuthInfo* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.user)
  return _msg;
}
inline void DebateEvent::set_allocated_user(::debate_event::UserAuthInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.user_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.user_ = reinterpret_cast<::debate_event::UserAuthInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:debate_event.DebateEvent.user)
}

// .google.protobuf.Timestamp occurred_at = 3 [json_name = "occurredAt"];
inline bool DebateEvent::has_occurred_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.occurred_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& DebateEvent::_internal_occurred_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.occurred_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& DebateEvent::occurred_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.occurred_at)
  return _internal_occurred_at();
}
inline void DebateEvent::unsafe_arena_set_allocated_occurred_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.occurred_at_);
  }
  _impl_.occurred_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.occurred_at)
}
inline ::google::protobuf::Timestamp* DebateEvent::release_occurred_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.occurred_at_;
  _impl_.occurred_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* DebateEvent::unsafe_arena_release_occurred_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.occurred_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.occurred_at_;
  _impl_.occurred_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* DebateEvent::_internal_mutable_occurred_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.occurred_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.occurred_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.occurred_at_;
}
inline ::google::protobuf::Timestamp* DebateEvent::mutable_occurred_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_occurred_at();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.occurred_at)
  return _msg;
}
inline void DebateEvent::set_allocated_occurred_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.occurred_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.occurred_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:debate_event.DebateEvent.occurred_at)
}

// .debate_event.EventType type = 4 [json_name = "type"];
inline void DebateEvent::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::debate_event::EventType DebateEvent::type() const {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.type)
  return _internal_type();
}
inline void DebateEvent::set_type(::debate_event::EventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:debate_event.DebateEvent.type)
}
inline ::debate_event::EventType DebateEvent::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::debate_event::EventType>(_impl_.type_);
}
inline void DebateEvent::_internal_set_type(::debate_event::EventType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .debate_event.CreateDebate create_debate = 10 [json_name = "createDebate"];
inline bool DebateEvent::has_create_debate() const {
  return payload_case() == kCreateDebate;
}
inline bool DebateEvent::_internal_has_create_debate() const {
  return payload_case() == kCreateDebate;
}
inline void DebateEvent::set_has_create_debate() {
  _impl_._oneof_case_[0] = kCreateDebate;
}
inline void DebateEvent::clear_create_debate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kCreateDebate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.create_debate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.create_debate_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::CreateDebate* DebateEvent::release_create_debate() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.create_debate)
  if (payload_case() == kCreateDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.create_debate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.create_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::CreateDebate& DebateEvent::_internal_create_debate() const {
  return payload_case() == kCreateDebate ? *_impl_.payload_.create_debate_ : reinterpret_cast<::debate_event::CreateDebate&>(::debate_event::_CreateDebate_default_instance_);
}
inline const ::debate_event::CreateDebate& DebateEvent::create_debate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.create_debate)
  return _internal_create_debate();
}
inline ::debate_event::CreateDebate* DebateEvent::unsafe_arena_release_create_debate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.create_debate)
  if (payload_case() == kCreateDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.create_debate_;
    _impl_.payload_.create_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_create_debate(::debate_event::CreateDebate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_create_debate();
    _impl_.payload_.create_debate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.create_debate)
}
inline ::debate_event::CreateDebate* DebateEvent::_internal_mutable_create_debate() {
  if (payload_case() != kCreateDebate) {
    clear_payload();
    set_has_create_debate();
    _impl_.payload_.create_debate_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::CreateDebate>(GetArena());
  }
  return _impl_.payload_.create_debate_;
}
inline ::debate_event::CreateDebate* DebateEvent::mutable_create_debate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::CreateDebate* _msg = _internal_mutable_create_debate();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.create_debate)
  return _msg;
}

// .debate_event.DeleteDebate delete_debate = 12 [json_name = "deleteDebate"];
inline bool DebateEvent::has_delete_debate() const {
  return payload_case() == kDeleteDebate;
}
inline bool DebateEvent::_internal_has_delete_debate() const {
  return payload_case() == kDeleteDebate;
}
inline void DebateEvent::set_has_delete_debate() {
  _impl_._oneof_case_[0] = kDeleteDebate;
}
inline void DebateEvent::clear_delete_debate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteDebate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.delete_debate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.delete_debate_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::DeleteDebate* DebateEvent::release_delete_debate() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.delete_debate)
  if (payload_case() == kDeleteDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_debate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::DeleteDebate& DebateEvent::_internal_delete_debate() const {
  return payload_case() == kDeleteDebate ? *_impl_.payload_.delete_debate_ : reinterpret_cast<::debate_event::DeleteDebate&>(::debate_event::_DeleteDebate_default_instance_);
}
inline const ::debate_event::DeleteDebate& DebateEvent::delete_debate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.delete_debate)
  return _internal_delete_debate();
}
inline ::debate_event::DeleteDebate* DebateEvent::unsafe_arena_release_delete_debate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.delete_debate)
  if (payload_case() == kDeleteDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_debate_;
    _impl_.payload_.delete_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_delete_debate(::debate_event::DeleteDebate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_delete_debate();
    _impl_.payload_.delete_debate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.delete_debate)
}
inline ::debate_event::DeleteDebate* DebateEvent::_internal_mutable_delete_debate() {
  if (payload_case() != kDeleteDebate) {
    clear_payload();
    set_has_delete_debate();
    _impl_.payload_.delete_debate_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::DeleteDebate>(GetArena());
  }
  return _impl_.payload_.delete_debate_;
}
inline ::debate_event::DeleteDebate* DebateEvent::mutable_delete_debate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::DeleteDebate* _msg = _internal_mutable_delete_debate();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.delete_debate)
  return _msg;
}

// .debate_event.EnterDebate enter_debate = 13 [json_name = "enterDebate"];
inline bool DebateEvent::has_enter_debate() const {
  return payload_case() == kEnterDebate;
}
inline bool DebateEvent::_internal_has_enter_debate() const {
  return payload_case() == kEnterDebate;
}
inline void DebateEvent::set_has_enter_debate() {
  _impl_._oneof_case_[0] = kEnterDebate;
}
inline void DebateEvent::clear_enter_debate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kEnterDebate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.enter_debate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.enter_debate_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::EnterDebate* DebateEvent::release_enter_debate() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.enter_debate)
  if (payload_case() == kEnterDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.enter_debate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.enter_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::EnterDebate& DebateEvent::_internal_enter_debate() const {
  return payload_case() == kEnterDebate ? *_impl_.payload_.enter_debate_ : reinterpret_cast<::debate_event::EnterDebate&>(::debate_event::_EnterDebate_default_instance_);
}
inline const ::debate_event::EnterDebate& DebateEvent::enter_debate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.enter_debate)
  return _internal_enter_debate();
}
inline ::debate_event::EnterDebate* DebateEvent::unsafe_arena_release_enter_debate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.enter_debate)
  if (payload_case() == kEnterDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.enter_debate_;
    _impl_.payload_.enter_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_enter_debate(::debate_event::EnterDebate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_enter_debate();
    _impl_.payload_.enter_debate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.enter_debate)
}
inline ::debate_event::EnterDebate* DebateEvent::_internal_mutable_enter_debate() {
  if (payload_case() != kEnterDebate) {
    clear_payload();
    set_has_enter_debate();
    _impl_.payload_.enter_debate_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::EnterDebate>(GetArena());
  }
  return _impl_.payload_.enter_debate_;
}
inline ::debate_event::EnterDebate* DebateEvent::mutable_enter_debate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::EnterDebate* _msg = _internal_mutable_enter_debate();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.enter_debate)
  return _msg;
}

// .debate_event.AddChildClaim add_child_claim = 16 [json_name = "addChildClaim"];
inline bool DebateEvent::has_add_child_claim() const {
  return payload_case() == kAddChildClaim;
}
inline bool DebateEvent::_internal_has_add_child_claim() const {
  return payload_case() == kAddChildClaim;
}
inline void DebateEvent::set_has_add_child_claim() {
  _impl_._oneof_case_[0] = kAddChildClaim;
}
inline void DebateEvent::clear_add_child_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAddChildClaim) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.add_child_claim_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.add_child_claim_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::AddChildClaim* DebateEvent::release_add_child_claim() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.add_child_claim)
  if (payload_case() == kAddChildClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.add_child_claim_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.add_child_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::AddChildClaim& DebateEvent::_internal_add_child_claim() const {
  return payload_case() == kAddChildClaim ? *_impl_.payload_.add_child_claim_ : reinterpret_cast<::debate_event::AddChildClaim&>(::debate_event::_AddChildClaim_default_instance_);
}
inline const ::debate_event::AddChildClaim& DebateEvent::add_child_claim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.add_child_claim)
  return _internal_add_child_claim();
}
inline ::debate_event::AddChildClaim* DebateEvent::unsafe_arena_release_add_child_claim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.add_child_claim)
  if (payload_case() == kAddChildClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.add_child_claim_;
    _impl_.payload_.add_child_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_add_child_claim(::debate_event::AddChildClaim* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_add_child_claim();
    _impl_.payload_.add_child_claim_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.add_child_claim)
}
inline ::debate_event::AddChildClaim* DebateEvent::_internal_mutable_add_child_claim() {
  if (payload_case() != kAddChildClaim) {
    clear_payload();
    set_has_add_child_claim();
    _impl_.payload_.add_child_claim_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::AddChildClaim>(GetArena());
  }
  return _impl_.payload_.add_child_claim_;
}
inline ::debate_event::AddChildClaim* DebateEvent::mutable_add_child_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::AddChildClaim* _msg = _internal_mutable_add_child_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.add_child_claim)
  return _msg;
}

// .debate_event.GoToClaim go_to_claim = 20 [json_name = "goToClaim"];
inline bool DebateEvent::has_go_to_claim() const {
  return payload_case() == kGoToClaim;
}
inline bool DebateEvent::_internal_has_go_to_claim() const {
  return payload_case() == kGoToClaim;
}
inline void DebateEvent::set_has_go_to_claim() {
  _impl_._oneof_case_[0] = kGoToClaim;
}
inline void DebateEvent::clear_go_to_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGoToClaim) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.go_to_claim_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.go_to_claim_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::GoToClaim* DebateEvent::release_go_to_claim() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.go_to_claim)
  if (payload_case() == kGoToClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.go_to_claim_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.go_to_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::GoToClaim& DebateEvent::_internal_go_to_claim() const {
  return payload_case() == kGoToClaim ? *_impl_.payload_.go_to_claim_ : reinterpret_cast<::debate_event::GoToClaim&>(::debate_event::_GoToClaim_default_instance_);
}
inline const ::debate_event::GoToClaim& DebateEvent::go_to_claim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.go_to_claim)
  return _internal_go_to_claim();
}
inline ::debate_event::GoToClaim* DebateEvent::unsafe_arena_release_go_to_claim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.go_to_claim)
  if (payload_case() == kGoToClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.go_to_claim_;
    _impl_.payload_.go_to_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_go_to_claim(::debate_event::GoToClaim* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_go_to_claim();
    _impl_.payload_.go_to_claim_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.go_to_claim)
}
inline ::debate_event::GoToClaim* DebateEvent::_internal_mutable_go_to_claim() {
  if (payload_case() != kGoToClaim) {
    clear_payload();
    set_has_go_to_claim();
    _impl_.payload_.go_to_claim_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::GoToClaim>(GetArena());
  }
  return _impl_.payload_.go_to_claim_;
}
inline ::debate_event::GoToClaim* DebateEvent::mutable_go_to_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::GoToClaim* _msg = _internal_mutable_go_to_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.go_to_claim)
  return _msg;
}

// .debate_event.DeleteChildClaim delete_child_claim = 23 [json_name = "deleteChildClaim"];
inline bool DebateEvent::has_delete_child_claim() const {
  return payload_case() == kDeleteChildClaim;
}
inline bool DebateEvent::_internal_has_delete_child_claim() const {
  return payload_case() == kDeleteChildClaim;
}
inline void DebateEvent::set_has_delete_child_claim() {
  _impl_._oneof_case_[0] = kDeleteChildClaim;
}
inline void DebateEvent::clear_delete_child_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteChildClaim) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.delete_child_claim_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.delete_child_claim_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::DeleteChildClaim* DebateEvent::release_delete_child_claim() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.delete_child_claim)
  if (payload_case() == kDeleteChildClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_child_claim_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_child_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::DeleteChildClaim& DebateEvent::_internal_delete_child_claim() const {
  return payload_case() == kDeleteChildClaim ? *_impl_.payload_.delete_child_claim_ : reinterpret_cast<::debate_event::DeleteChildClaim&>(::debate_event::_DeleteChildClaim_default_instance_);
}
inline const ::debate_event::DeleteChildClaim& DebateEvent::delete_child_claim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.delete_child_claim)
  return _internal_delete_child_claim();
}
inline ::debate_event::DeleteChildClaim* DebateEvent::unsafe_arena_release_delete_child_claim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.delete_child_claim)
  if (payload_case() == kDeleteChildClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_child_claim_;
    _impl_.payload_.delete_child_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_delete_child_claim(::debate_event::DeleteChildClaim* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_delete_child_claim();
    _impl_.payload_.delete_child_claim_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.delete_child_claim)
}
inline ::debate_event::DeleteChildClaim* DebateEvent::_internal_mutable_delete_child_claim() {
  if (payload_case() != kDeleteChildClaim) {
    clear_payload();
    set_has_delete_child_claim();
    _impl_.payload_.delete_child_claim_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::DeleteChildClaim>(GetArena());
  }
  return _impl_.payload_.delete_child_claim_;
}
inline ::debate_event::DeleteChildClaim* DebateEvent::mutable_delete_child_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::DeleteChildClaim* _msg = _internal_mutable_delete_child_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.delete_child_claim)
  return _msg;
}

// .debate_event.SubmitEditClaimDescription submit_edit_claim_description = 25 [json_name = "submitEditClaimDescription"];
inline bool DebateEvent::has_submit_edit_claim_description() const {
  return payload_case() == kSubmitEditClaimDescription;
}
inline bool DebateEvent::_internal_has_submit_edit_claim_description() const {
  return payload_case() == kSubmitEditClaimDescription;
}
inline void DebateEvent::set_has_submit_edit_claim_description() {
  _impl_._oneof_case_[0] = kSubmitEditClaimDescription;
}
inline void DebateEvent::clear_submit_edit_claim_description() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSubmitEditClaimDescription) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.submit_edit_claim_description_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.submit_edit_claim_description_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::SubmitEditClaimDescription* DebateEvent::release_submit_edit_claim_description() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.submit_edit_claim_description)
  if (payload_case() == kSubmitEditClaimDescription) {
    clear_has_payload();
    auto* temp = _impl_.payload_.submit_edit_claim_description_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.submit_edit_claim_description_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::SubmitEditClaimDescription& DebateEvent::_internal_submit_edit_claim_description() const {
  return payload_case() == kSubmitEditClaimDescription ? *_impl_.payload_.submit_edit_claim_description_ : reinterpret_cast<::debate_event::SubmitEditClaimDescription&>(::debate_event::_SubmitEditClaimDescription_default_instance_);
}
inline const ::debate_event::SubmitEditClaimDescription& DebateEvent::submit_edit_claim_description() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.submit_edit_claim_description)
  return _internal_submit_edit_claim_description();
}
inline ::debate_event::SubmitEditClaimDescription* DebateEvent::unsafe_arena_release_submit_edit_claim_description() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.submit_edit_claim_description)
  if (payload_case() == kSubmitEditClaimDescription) {
    clear_has_payload();
    auto* temp = _impl_.payload_.submit_edit_claim_description_;
    _impl_.payload_.submit_edit_claim_description_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_submit_edit_claim_description(::debate_event::SubmitEditClaimDescription* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_submit_edit_claim_description();
    _impl_.payload_.submit_edit_claim_description_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.submit_edit_claim_description)
}
inline ::debate_event::SubmitEditClaimDescription* DebateEvent::_internal_mutable_submit_edit_claim_description() {
  if (payload_case() != kSubmitEditClaimDescription) {
    clear_payload();
    set_has_submit_edit_claim_description();
    _impl_.payload_.submit_edit_claim_description_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::SubmitEditClaimDescription>(GetArena());
  }
  return _impl_.payload_.submit_edit_claim_description_;
}
inline ::debate_event::SubmitEditClaimDescription* DebateEvent::mutable_submit_edit_claim_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::SubmitEditClaimDescription* _msg = _internal_mutable_submit_edit_claim_description();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.submit_edit_claim_description)
  return _msg;
}

// .debate_event.SubmitEditClaim submit_edit_claim = 28 [json_name = "submitEditClaim"];
inline bool DebateEvent::has_submit_edit_claim() const {
  return payload_case() == kSubmitEditClaim;
}
inline bool DebateEvent::_internal_has_submit_edit_claim() const {
  return payload_case() == kSubmitEditClaim;
}
inline void DebateEvent::set_has_submit_edit_claim() {
  _impl_._oneof_case_[0] = kSubmitEditClaim;
}
inline void DebateEvent::clear_submit_edit_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSubmitEditClaim) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.submit_edit_claim_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.submit_edit_claim_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::SubmitEditClaim* DebateEvent::release_submit_edit_claim() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.submit_edit_claim)
  if (payload_case() == kSubmitEditClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.submit_edit_claim_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.submit_edit_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::SubmitEditClaim& DebateEvent::_internal_submit_edit_claim() const {
  return payload_case() == kSubmitEditClaim ? *_impl_.payload_.submit_edit_claim_ : reinterpret_cast<::debate_event::SubmitEditClaim&>(::debate_event::_SubmitEditClaim_default_instance_);
}
inline const ::debate_event::SubmitEditClaim& DebateEvent::submit_edit_claim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.submit_edit_claim)
  return _internal_submit_edit_claim();
}
inline ::debate_event::SubmitEditClaim* DebateEvent::unsafe_arena_release_submit_edit_claim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.submit_edit_claim)
  if (payload_case() == kSubmitEditClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.submit_edit_claim_;
    _impl_.payload_.submit_edit_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_submit_edit_claim(::debate_event::SubmitEditClaim* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_submit_edit_claim();
    _impl_.payload_.submit_edit_claim_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.submit_edit_claim)
}
inline ::debate_event::SubmitEditClaim* DebateEvent::_internal_mutable_submit_edit_claim() {
  if (payload_case() != kSubmitEditClaim) {
    clear_payload();
    set_has_submit_edit_claim();
    _impl_.payload_.submit_edit_claim_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::SubmitEditClaim>(GetArena());
  }
  return _impl_.payload_.submit_edit_claim_;
}
inline ::debate_event::SubmitEditClaim* DebateEvent::mutable_submit_edit_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::SubmitEditClaim* _msg = _internal_mutable_submit_edit_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.submit_edit_claim)
  return _msg;
}

// .debate_event.ConnectFromClaim connect_from_claim = 30 [json_name = "connectFromClaim"];
inline bool DebateEvent::has_connect_from_claim() const {
  return payload_case() == kConnectFromClaim;
}
inline bool DebateEvent::_internal_has_connect_from_claim() const {
  return payload_case() == kConnectFromClaim;
}
inline void DebateEvent::set_has_connect_from_claim() {
  _impl_._oneof_case_[0] = kConnectFromClaim;
}
inline void DebateEvent::clear_connect_from_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kConnectFromClaim) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.connect_from_claim_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.connect_from_claim_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::ConnectFromClaim* DebateEvent::release_connect_from_claim() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.connect_from_claim)
  if (payload_case() == kConnectFromClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.connect_from_claim_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.connect_from_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::ConnectFromClaim& DebateEvent::_internal_connect_from_claim() const {
  return payload_case() == kConnectFromClaim ? *_impl_.payload_.connect_from_claim_ : reinterpret_cast<::debate_event::ConnectFromClaim&>(::debate_event::_ConnectFromClaim_default_instance_);
}
inline const ::debate_event::ConnectFromClaim& DebateEvent::connect_from_claim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.connect_from_claim)
  return _internal_connect_from_claim();
}
inline ::debate_event::ConnectFromClaim* DebateEvent::unsafe_arena_release_connect_from_claim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.connect_from_claim)
  if (payload_case() == kConnectFromClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.connect_from_claim_;
    _impl_.payload_.connect_from_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_connect_from_claim(::debate_event::ConnectFromClaim* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_connect_from_claim();
    _impl_.payload_.connect_from_claim_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.connect_from_claim)
}
inline ::debate_event::ConnectFromClaim* DebateEvent::_internal_mutable_connect_from_claim() {
  if (payload_case() != kConnectFromClaim) {
    clear_payload();
    set_has_connect_from_claim();
    _impl_.payload_.connect_from_claim_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::ConnectFromClaim>(GetArena());
  }
  return _impl_.payload_.connect_from_claim_;
}
inline ::debate_event::ConnectFromClaim* DebateEvent::mutable_connect_from_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::ConnectFromClaim* _msg = _internal_mutable_connect_from_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.connect_from_claim)
  return _msg;
}

// .debate_event.ConnectToClaim connect_to_claim = 31 [json_name = "connectToClaim"];
inline bool DebateEvent::has_connect_to_claim() const {
  return payload_case() == kConnectToClaim;
}
inline bool DebateEvent::_internal_has_connect_to_claim() const {
  return payload_case() == kConnectToClaim;
}
inline void DebateEvent::set_has_connect_to_claim() {
  _impl_._oneof_case_[0] = kConnectToClaim;
}
inline void DebateEvent::clear_connect_to_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kConnectToClaim) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.connect_to_claim_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.connect_to_claim_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::ConnectToClaim* DebateEvent::release_connect_to_claim() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.connect_to_claim)
  if (payload_case() == kConnectToClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.connect_to_claim_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.connect_to_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::ConnectToClaim& DebateEvent::_internal_connect_to_claim() const {
  return payload_case() == kConnectToClaim ? *_impl_.payload_.connect_to_claim_ : reinterpret_cast<::debate_event::ConnectToClaim&>(::debate_event::_ConnectToClaim_default_instance_);
}
inline const ::debate_event::ConnectToClaim& DebateEvent::connect_to_claim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.connect_to_claim)
  return _internal_connect_to_claim();
}
inline ::debate_event::ConnectToClaim* DebateEvent::unsafe_arena_release_connect_to_claim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.connect_to_claim)
  if (payload_case() == kConnectToClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.connect_to_claim_;
    _impl_.payload_.connect_to_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_connect_to_claim(::debate_event::ConnectToClaim* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_connect_to_claim();
    _impl_.payload_.connect_to_claim_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.connect_to_claim)
}
inline ::debate_event::ConnectToClaim* DebateEvent::_internal_mutable_connect_to_claim() {
  if (payload_case() != kConnectToClaim) {
    clear_payload();
    set_has_connect_to_claim();
    _impl_.payload_.connect_to_claim_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::ConnectToClaim>(GetArena());
  }
  return _impl_.payload_.connect_to_claim_;
}
inline ::debate_event::ConnectToClaim* DebateEvent::mutable_connect_to_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::ConnectToClaim* _msg = _internal_mutable_connect_to_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.connect_to_claim)
  return _msg;
}

// .debate_event.SubmitConnectClaims submit_connect_claims = 32 [json_name = "submitConnectClaims"];
inline bool DebateEvent::has_submit_connect_claims() const {
  return payload_case() == kSubmitConnectClaims;
}
inline bool DebateEvent::_internal_has_submit_connect_claims() const {
  return payload_case() == kSubmitConnectClaims;
}
inline void DebateEvent::set_has_submit_connect_claims() {
  _impl_._oneof_case_[0] = kSubmitConnectClaims;
}
inline void DebateEvent::clear_submit_connect_claims() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSubmitConnectClaims) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.submit_connect_claims_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.submit_connect_claims_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::SubmitConnectClaims* DebateEvent::release_submit_connect_claims() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.submit_connect_claims)
  if (payload_case() == kSubmitConnectClaims) {
    clear_has_payload();
    auto* temp = _impl_.payload_.submit_connect_claims_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.submit_connect_claims_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::SubmitConnectClaims& DebateEvent::_internal_submit_connect_claims() const {
  return payload_case() == kSubmitConnectClaims ? *_impl_.payload_.submit_connect_claims_ : reinterpret_cast<::debate_event::SubmitConnectClaims&>(::debate_event::_SubmitConnectClaims_default_instance_);
}
inline const ::debate_event::SubmitConnectClaims& DebateEvent::submit_connect_claims() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.submit_connect_claims)
  return _internal_submit_connect_claims();
}
inline ::debate_event::SubmitConnectClaims* DebateEvent::unsafe_arena_release_submit_connect_claims() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.submit_connect_claims)
  if (payload_case() == kSubmitConnectClaims) {
    clear_has_payload();
    auto* temp = _impl_.payload_.submit_connect_claims_;
    _impl_.payload_.submit_connect_claims_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_submit_connect_claims(::debate_event::SubmitConnectClaims* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_submit_connect_claims();
    _impl_.payload_.submit_connect_claims_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.submit_connect_claims)
}
inline ::debate_event::SubmitConnectClaims* DebateEvent::_internal_mutable_submit_connect_claims() {
  if (payload_case() != kSubmitConnectClaims) {
    clear_payload();
    set_has_submit_connect_claims();
    _impl_.payload_.submit_connect_claims_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::SubmitConnectClaims>(GetArena());
  }
  return _impl_.payload_.submit_connect_claims_;
}
inline ::debate_event::SubmitConnectClaims* DebateEvent::mutable_submit_connect_claims() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::SubmitConnectClaims* _msg = _internal_mutable_submit_connect_claims();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.submit_connect_claims)
  return _msg;
}

// .debate_event.DeleteLink delete_link = 34 [json_name = "deleteLink"];
inline bool DebateEvent::has_delete_link() const {
  return payload_case() == kDeleteLink;
}
inline bool DebateEvent::_internal_has_delete_link() const {
  return payload_case() == kDeleteLink;
}
inline void DebateEvent::set_has_delete_link() {
  _impl_._oneof_case_[0] = kDeleteLink;
}
inline void DebateEvent::clear_delete_link() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteLink) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.delete_link_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.delete_link_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::DeleteLink* DebateEvent::release_delete_link() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.delete_link)
  if (payload_case() == kDeleteLink) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_link_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::DeleteLink& DebateEvent::_internal_delete_link() const {
  return payload_case() == kDeleteLink ? *_impl_.payload_.delete_link_ : reinterpret_cast<::debate_event::DeleteLink&>(::debate_event::_DeleteLink_default_instance_);
}
inline const ::debate_event::DeleteLink& DebateEvent::delete_link() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.delete_link)
  return _internal_delete_link();
}
inline ::debate_event::DeleteLink* DebateEvent::unsafe_arena_release_delete_link() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.delete_link)
  if (payload_case() == kDeleteLink) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_link_;
    _impl_.payload_.delete_link_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_delete_link(::debate_event::DeleteLink* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_delete_link();
    _impl_.payload_.delete_link_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.delete_link)
}
inline ::debate_event::DeleteLink* DebateEvent::_internal_mutable_delete_link() {
  if (payload_case() != kDeleteLink) {
    clear_payload();
    set_has_delete_link();
    _impl_.payload_.delete_link_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::DeleteLink>(GetArena());
  }
  return _impl_.payload_.delete_link_;
}
inline ::debate_event::DeleteLink* DebateEvent::mutable_delete_link() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::DeleteLink* _msg = _internal_mutable_delete_link();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.delete_link)
  return _msg;
}

// .debate_event.JoinDebate join_debate = 35 [json_name = "joinDebate"];
inline bool DebateEvent::has_join_debate() const {
  return payload_case() == kJoinDebate;
}
inline bool DebateEvent::_internal_has_join_debate() const {
  return payload_case() == kJoinDebate;
}
inline void DebateEvent::set_has_join_debate() {
  _impl_._oneof_case_[0] = kJoinDebate;
}
inline void DebateEvent::clear_join_debate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kJoinDebate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.join_debate_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.join_debate_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::JoinDebate* DebateEvent::release_join_debate() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.join_debate)
  if (payload_case() == kJoinDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.join_debate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.join_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::JoinDebate& DebateEvent::_internal_join_debate() const {
  return payload_case() == kJoinDebate ? *_impl_.payload_.join_debate_ : reinterpret_cast<::debate_event::JoinDebate&>(::debate_event::_JoinDebate_default_instance_);
}
inline const ::debate_event::JoinDebate& DebateEvent::join_debate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.join_debate)
  return _internal_join_debate();
}
inline ::debate_event::JoinDebate* DebateEvent::unsafe_arena_release_join_debate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.join_debate)
  if (payload_case() == kJoinDebate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.join_debate_;
    _impl_.payload_.join_debate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_join_debate(::debate_event::JoinDebate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_join_debate();
    _impl_.payload_.join_debate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.join_debate)
}
inline ::debate_event::JoinDebate* DebateEvent::_internal_mutable_join_debate() {
  if (payload_case() != kJoinDebate) {
    clear_payload();
    set_has_join_debate();
    _impl_.payload_.join_debate_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::JoinDebate>(GetArena());
  }
  return _impl_.payload_.join_debate_;
}
inline ::debate_event::JoinDebate* DebateEvent::mutable_join_debate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::JoinDebate* _msg = _internal_mutable_join_debate();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.join_debate)
  return _msg;
}

// .debate_event.Login login = 36 [json_name = "login"];
inline bool DebateEvent::has_login() const {
  return payload_case() == kLogin;
}
inline bool DebateEvent::_internal_has_login() const {
  return payload_case() == kLogin;
}
inline void DebateEvent::set_has_login() {
  _impl_._oneof_case_[0] = kLogin;
}
inline void DebateEvent::clear_login() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kLogin) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.login_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.login_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::Login* DebateEvent::release_login() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.login)
  if (payload_case() == kLogin) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::Login& DebateEvent::_internal_login() const {
  return payload_case() == kLogin ? *_impl_.payload_.login_ : reinterpret_cast<::debate_event::Login&>(::debate_event::_Login_default_instance_);
}
inline const ::debate_event::Login& DebateEvent::login() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.login)
  return _internal_login();
}
inline ::debate_event::Login* DebateEvent::unsafe_arena_release_login() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.login)
  if (payload_case() == kLogin) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_;
    _impl_.payload_.login_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_login(::debate_event::Login* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_login();
    _impl_.payload_.login_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.login)
}
inline ::debate_event::Login* DebateEvent::_internal_mutable_login() {
  if (payload_case() != kLogin) {
    clear_payload();
    set_has_login();
    _impl_.payload_.login_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::Login>(GetArena());
  }
  return _impl_.payload_.login_;
}
inline ::debate_event::Login* DebateEvent::mutable_login() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::Login* _msg = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.login)
  return _msg;
}

// .debate_event.AddClaimToBeChallenged add_claim_to_be_challenged = 38 [json_name = "addClaimToBeChallenged"];
inline bool DebateEvent::has_add_claim_to_be_challenged() const {
  return payload_case() == kAddClaimToBeChallenged;
}
inline bool DebateEvent::_internal_has_add_claim_to_be_challenged() const {
  return payload_case() == kAddClaimToBeChallenged;
}
inline void DebateEvent::set_has_add_claim_to_be_challenged() {
  _impl_._oneof_case_[0] = kAddClaimToBeChallenged;
}
inline void DebateEvent::clear_add_claim_to_be_challenged() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAddClaimToBeChallenged) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.add_claim_to_be_challenged_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.add_claim_to_be_challenged_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::AddClaimToBeChallenged* DebateEvent::release_add_claim_to_be_challenged() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.add_claim_to_be_challenged)
  if (payload_case() == kAddClaimToBeChallenged) {
    clear_has_payload();
    auto* temp = _impl_.payload_.add_claim_to_be_challenged_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.add_claim_to_be_challenged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::AddClaimToBeChallenged& DebateEvent::_internal_add_claim_to_be_challenged() const {
  return payload_case() == kAddClaimToBeChallenged ? *_impl_.payload_.add_claim_to_be_challenged_ : reinterpret_cast<::debate_event::AddClaimToBeChallenged&>(::debate_event::_AddClaimToBeChallenged_default_instance_);
}
inline const ::debate_event::AddClaimToBeChallenged& DebateEvent::add_claim_to_be_challenged() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.add_claim_to_be_challenged)
  return _internal_add_claim_to_be_challenged();
}
inline ::debate_event::AddClaimToBeChallenged* DebateEvent::unsafe_arena_release_add_claim_to_be_challenged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.add_claim_to_be_challenged)
  if (payload_case() == kAddClaimToBeChallenged) {
    clear_has_payload();
    auto* temp = _impl_.payload_.add_claim_to_be_challenged_;
    _impl_.payload_.add_claim_to_be_challenged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_add_claim_to_be_challenged(::debate_event::AddClaimToBeChallenged* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_add_claim_to_be_challenged();
    _impl_.payload_.add_claim_to_be_challenged_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.add_claim_to_be_challenged)
}
inline ::debate_event::AddClaimToBeChallenged* DebateEvent::_internal_mutable_add_claim_to_be_challenged() {
  if (payload_case() != kAddClaimToBeChallenged) {
    clear_payload();
    set_has_add_claim_to_be_challenged();
    _impl_.payload_.add_claim_to_be_challenged_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::AddClaimToBeChallenged>(GetArena());
  }
  return _impl_.payload_.add_claim_to_be_challenged_;
}
inline ::debate_event::AddClaimToBeChallenged* DebateEvent::mutable_add_claim_to_be_challenged() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::AddClaimToBeChallenged* _msg = _internal_mutable_add_claim_to_be_challenged();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.add_claim_to_be_challenged)
  return _msg;
}

// .debate_event.AddLinkToBeChallenged add_link_to_be_challenged = 39 [json_name = "addLinkToBeChallenged"];
inline bool DebateEvent::has_add_link_to_be_challenged() const {
  return payload_case() == kAddLinkToBeChallenged;
}
inline bool DebateEvent::_internal_has_add_link_to_be_challenged() const {
  return payload_case() == kAddLinkToBeChallenged;
}
inline void DebateEvent::set_has_add_link_to_be_challenged() {
  _impl_._oneof_case_[0] = kAddLinkToBeChallenged;
}
inline void DebateEvent::clear_add_link_to_be_challenged() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kAddLinkToBeChallenged) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.add_link_to_be_challenged_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.add_link_to_be_challenged_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::AddLinkToBeChallenged* DebateEvent::release_add_link_to_be_challenged() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.add_link_to_be_challenged)
  if (payload_case() == kAddLinkToBeChallenged) {
    clear_has_payload();
    auto* temp = _impl_.payload_.add_link_to_be_challenged_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.add_link_to_be_challenged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::AddLinkToBeChallenged& DebateEvent::_internal_add_link_to_be_challenged() const {
  return payload_case() == kAddLinkToBeChallenged ? *_impl_.payload_.add_link_to_be_challenged_ : reinterpret_cast<::debate_event::AddLinkToBeChallenged&>(::debate_event::_AddLinkToBeChallenged_default_instance_);
}
inline const ::debate_event::AddLinkToBeChallenged& DebateEvent::add_link_to_be_challenged() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.add_link_to_be_challenged)
  return _internal_add_link_to_be_challenged();
}
inline ::debate_event::AddLinkToBeChallenged* DebateEvent::unsafe_arena_release_add_link_to_be_challenged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.add_link_to_be_challenged)
  if (payload_case() == kAddLinkToBeChallenged) {
    clear_has_payload();
    auto* temp = _impl_.payload_.add_link_to_be_challenged_;
    _impl_.payload_.add_link_to_be_challenged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_add_link_to_be_challenged(::debate_event::AddLinkToBeChallenged* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_add_link_to_be_challenged();
    _impl_.payload_.add_link_to_be_challenged_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.add_link_to_be_challenged)
}
inline ::debate_event::AddLinkToBeChallenged* DebateEvent::_internal_mutable_add_link_to_be_challenged() {
  if (payload_case() != kAddLinkToBeChallenged) {
    clear_payload();
    set_has_add_link_to_be_challenged();
    _impl_.payload_.add_link_to_be_challenged_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::AddLinkToBeChallenged>(GetArena());
  }
  return _impl_.payload_.add_link_to_be_challenged_;
}
inline ::debate_event::AddLinkToBeChallenged* DebateEvent::mutable_add_link_to_be_challenged() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::AddLinkToBeChallenged* _msg = _internal_mutable_add_link_to_be_challenged();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.add_link_to_be_challenged)
  return _msg;
}

// .debate_event.SubmitChallengeClaim submit_challenge_claim = 40 [json_name = "submitChallengeClaim"];
inline bool DebateEvent::has_submit_challenge_claim() const {
  return payload_case() == kSubmitChallengeClaim;
}
inline bool DebateEvent::_internal_has_submit_challenge_claim() const {
  return payload_case() == kSubmitChallengeClaim;
}
inline void DebateEvent::set_has_submit_challenge_claim() {
  _impl_._oneof_case_[0] = kSubmitChallengeClaim;
}
inline void DebateEvent::clear_submit_challenge_claim() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kSubmitChallengeClaim) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.submit_challenge_claim_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.submit_challenge_claim_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::SubmitChallengeClaim* DebateEvent::release_submit_challenge_claim() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.submit_challenge_claim)
  if (payload_case() == kSubmitChallengeClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.submit_challenge_claim_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.submit_challenge_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::SubmitChallengeClaim& DebateEvent::_internal_submit_challenge_claim() const {
  return payload_case() == kSubmitChallengeClaim ? *_impl_.payload_.submit_challenge_claim_ : reinterpret_cast<::debate_event::SubmitChallengeClaim&>(::debate_event::_SubmitChallengeClaim_default_instance_);
}
inline const ::debate_event::SubmitChallengeClaim& DebateEvent::submit_challenge_claim() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.submit_challenge_claim)
  return _internal_submit_challenge_claim();
}
inline ::debate_event::SubmitChallengeClaim* DebateEvent::unsafe_arena_release_submit_challenge_claim() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.submit_challenge_claim)
  if (payload_case() == kSubmitChallengeClaim) {
    clear_has_payload();
    auto* temp = _impl_.payload_.submit_challenge_claim_;
    _impl_.payload_.submit_challenge_claim_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_submit_challenge_claim(::debate_event::SubmitChallengeClaim* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_submit_challenge_claim();
    _impl_.payload_.submit_challenge_claim_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.submit_challenge_claim)
}
inline ::debate_event::SubmitChallengeClaim* DebateEvent::_internal_mutable_submit_challenge_claim() {
  if (payload_case() != kSubmitChallengeClaim) {
    clear_payload();
    set_has_submit_challenge_claim();
    _impl_.payload_.submit_challenge_claim_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::SubmitChallengeClaim>(GetArena());
  }
  return _impl_.payload_.submit_challenge_claim_;
}
inline ::debate_event::SubmitChallengeClaim* DebateEvent::mutable_submit_challenge_claim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::SubmitChallengeClaim* _msg = _internal_mutable_submit_challenge_claim();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.submit_challenge_claim)
  return _msg;
}

// .debate_event.GoToChallenge go_to_challenge = 41 [json_name = "goToChallenge"];
inline bool DebateEvent::has_go_to_challenge() const {
  return payload_case() == kGoToChallenge;
}
inline bool DebateEvent::_internal_has_go_to_challenge() const {
  return payload_case() == kGoToChallenge;
}
inline void DebateEvent::set_has_go_to_challenge() {
  _impl_._oneof_case_[0] = kGoToChallenge;
}
inline void DebateEvent::clear_go_to_challenge() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kGoToChallenge) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.go_to_challenge_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.go_to_challenge_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::GoToChallenge* DebateEvent::release_go_to_challenge() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.go_to_challenge)
  if (payload_case() == kGoToChallenge) {
    clear_has_payload();
    auto* temp = _impl_.payload_.go_to_challenge_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.go_to_challenge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::GoToChallenge& DebateEvent::_internal_go_to_challenge() const {
  return payload_case() == kGoToChallenge ? *_impl_.payload_.go_to_challenge_ : reinterpret_cast<::debate_event::GoToChallenge&>(::debate_event::_GoToChallenge_default_instance_);
}
inline const ::debate_event::GoToChallenge& DebateEvent::go_to_challenge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.go_to_challenge)
  return _internal_go_to_challenge();
}
inline ::debate_event::GoToChallenge* DebateEvent::unsafe_arena_release_go_to_challenge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.go_to_challenge)
  if (payload_case() == kGoToChallenge) {
    clear_has_payload();
    auto* temp = _impl_.payload_.go_to_challenge_;
    _impl_.payload_.go_to_challenge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_go_to_challenge(::debate_event::GoToChallenge* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_go_to_challenge();
    _impl_.payload_.go_to_challenge_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.go_to_challenge)
}
inline ::debate_event::GoToChallenge* DebateEvent::_internal_mutable_go_to_challenge() {
  if (payload_case() != kGoToChallenge) {
    clear_payload();
    set_has_go_to_challenge();
    _impl_.payload_.go_to_challenge_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::GoToChallenge>(GetArena());
  }
  return _impl_.payload_.go_to_challenge_;
}
inline ::debate_event::GoToChallenge* DebateEvent::mutable_go_to_challenge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::GoToChallenge* _msg = _internal_mutable_go_to_challenge();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.go_to_challenge)
  return _msg;
}

// .debate_event.ConcedeChallenge concede_challenge = 42 [json_name = "concedeChallenge"];
inline bool DebateEvent::has_concede_challenge() const {
  return payload_case() == kConcedeChallenge;
}
inline bool DebateEvent::_internal_has_concede_challenge() const {
  return payload_case() == kConcedeChallenge;
}
inline void DebateEvent::set_has_concede_challenge() {
  _impl_._oneof_case_[0] = kConcedeChallenge;
}
inline void DebateEvent::clear_concede_challenge() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kConcedeChallenge) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.concede_challenge_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.concede_challenge_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::ConcedeChallenge* DebateEvent::release_concede_challenge() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.concede_challenge)
  if (payload_case() == kConcedeChallenge) {
    clear_has_payload();
    auto* temp = _impl_.payload_.concede_challenge_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.concede_challenge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::ConcedeChallenge& DebateEvent::_internal_concede_challenge() const {
  return payload_case() == kConcedeChallenge ? *_impl_.payload_.concede_challenge_ : reinterpret_cast<::debate_event::ConcedeChallenge&>(::debate_event::_ConcedeChallenge_default_instance_);
}
inline const ::debate_event::ConcedeChallenge& DebateEvent::concede_challenge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.concede_challenge)
  return _internal_concede_challenge();
}
inline ::debate_event::ConcedeChallenge* DebateEvent::unsafe_arena_release_concede_challenge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.concede_challenge)
  if (payload_case() == kConcedeChallenge) {
    clear_has_payload();
    auto* temp = _impl_.payload_.concede_challenge_;
    _impl_.payload_.concede_challenge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_concede_challenge(::debate_event::ConcedeChallenge* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_concede_challenge();
    _impl_.payload_.concede_challenge_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.concede_challenge)
}
inline ::debate_event::ConcedeChallenge* DebateEvent::_internal_mutable_concede_challenge() {
  if (payload_case() != kConcedeChallenge) {
    clear_payload();
    set_has_concede_challenge();
    _impl_.payload_.concede_challenge_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::ConcedeChallenge>(GetArena());
  }
  return _impl_.payload_.concede_challenge_;
}
inline ::debate_event::ConcedeChallenge* DebateEvent::mutable_concede_challenge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::ConcedeChallenge* _msg = _internal_mutable_concede_challenge();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.concede_challenge)
  return _msg;
}

// .debate_event.RemoveClaimToBeChallenged remove_claim_to_be_challenged = 46 [json_name = "removeClaimToBeChallenged"];
inline bool DebateEvent::has_remove_claim_to_be_challenged() const {
  return payload_case() == kRemoveClaimToBeChallenged;
}
inline bool DebateEvent::_internal_has_remove_claim_to_be_challenged() const {
  return payload_case() == kRemoveClaimToBeChallenged;
}
inline void DebateEvent::set_has_remove_claim_to_be_challenged() {
  _impl_._oneof_case_[0] = kRemoveClaimToBeChallenged;
}
inline void DebateEvent::clear_remove_claim_to_be_challenged() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kRemoveClaimToBeChallenged) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.remove_claim_to_be_challenged_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.remove_claim_to_be_challenged_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::RemoveClaimToBeChallenged* DebateEvent::release_remove_claim_to_be_challenged() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.remove_claim_to_be_challenged)
  if (payload_case() == kRemoveClaimToBeChallenged) {
    clear_has_payload();
    auto* temp = _impl_.payload_.remove_claim_to_be_challenged_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.remove_claim_to_be_challenged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::RemoveClaimToBeChallenged& DebateEvent::_internal_remove_claim_to_be_challenged() const {
  return payload_case() == kRemoveClaimToBeChallenged ? *_impl_.payload_.remove_claim_to_be_challenged_ : reinterpret_cast<::debate_event::RemoveClaimToBeChallenged&>(::debate_event::_RemoveClaimToBeChallenged_default_instance_);
}
inline const ::debate_event::RemoveClaimToBeChallenged& DebateEvent::remove_claim_to_be_challenged() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.remove_claim_to_be_challenged)
  return _internal_remove_claim_to_be_challenged();
}
inline ::debate_event::RemoveClaimToBeChallenged* DebateEvent::unsafe_arena_release_remove_claim_to_be_challenged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.remove_claim_to_be_challenged)
  if (payload_case() == kRemoveClaimToBeChallenged) {
    clear_has_payload();
    auto* temp = _impl_.payload_.remove_claim_to_be_challenged_;
    _impl_.payload_.remove_claim_to_be_challenged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_remove_claim_to_be_challenged(::debate_event::RemoveClaimToBeChallenged* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_remove_claim_to_be_challenged();
    _impl_.payload_.remove_claim_to_be_challenged_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.remove_claim_to_be_challenged)
}
inline ::debate_event::RemoveClaimToBeChallenged* DebateEvent::_internal_mutable_remove_claim_to_be_challenged() {
  if (payload_case() != kRemoveClaimToBeChallenged) {
    clear_payload();
    set_has_remove_claim_to_be_challenged();
    _impl_.payload_.remove_claim_to_be_challenged_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::RemoveClaimToBeChallenged>(GetArena());
  }
  return _impl_.payload_.remove_claim_to_be_challenged_;
}
inline ::debate_event::RemoveClaimToBeChallenged* DebateEvent::mutable_remove_claim_to_be_challenged() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::RemoveClaimToBeChallenged* _msg = _internal_mutable_remove_claim_to_be_challenged();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.remove_claim_to_be_challenged)
  return _msg;
}

// .debate_event.RemoveLinkToBeChallenged remove_link_to_be_challenged = 47 [json_name = "removeLinkToBeChallenged"];
inline bool DebateEvent::has_remove_link_to_be_challenged() const {
  return payload_case() == kRemoveLinkToBeChallenged;
}
inline bool DebateEvent::_internal_has_remove_link_to_be_challenged() const {
  return payload_case() == kRemoveLinkToBeChallenged;
}
inline void DebateEvent::set_has_remove_link_to_be_challenged() {
  _impl_._oneof_case_[0] = kRemoveLinkToBeChallenged;
}
inline void DebateEvent::clear_remove_link_to_be_challenged() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kRemoveLinkToBeChallenged) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.remove_link_to_be_challenged_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.remove_link_to_be_challenged_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::RemoveLinkToBeChallenged* DebateEvent::release_remove_link_to_be_challenged() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.remove_link_to_be_challenged)
  if (payload_case() == kRemoveLinkToBeChallenged) {
    clear_has_payload();
    auto* temp = _impl_.payload_.remove_link_to_be_challenged_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.remove_link_to_be_challenged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::RemoveLinkToBeChallenged& DebateEvent::_internal_remove_link_to_be_challenged() const {
  return payload_case() == kRemoveLinkToBeChallenged ? *_impl_.payload_.remove_link_to_be_challenged_ : reinterpret_cast<::debate_event::RemoveLinkToBeChallenged&>(::debate_event::_RemoveLinkToBeChallenged_default_instance_);
}
inline const ::debate_event::RemoveLinkToBeChallenged& DebateEvent::remove_link_to_be_challenged() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.remove_link_to_be_challenged)
  return _internal_remove_link_to_be_challenged();
}
inline ::debate_event::RemoveLinkToBeChallenged* DebateEvent::unsafe_arena_release_remove_link_to_be_challenged() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.remove_link_to_be_challenged)
  if (payload_case() == kRemoveLinkToBeChallenged) {
    clear_has_payload();
    auto* temp = _impl_.payload_.remove_link_to_be_challenged_;
    _impl_.payload_.remove_link_to_be_challenged_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_remove_link_to_be_challenged(::debate_event::RemoveLinkToBeChallenged* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_remove_link_to_be_challenged();
    _impl_.payload_.remove_link_to_be_challenged_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.remove_link_to_be_challenged)
}
inline ::debate_event::RemoveLinkToBeChallenged* DebateEvent::_internal_mutable_remove_link_to_be_challenged() {
  if (payload_case() != kRemoveLinkToBeChallenged) {
    clear_payload();
    set_has_remove_link_to_be_challenged();
    _impl_.payload_.remove_link_to_be_challenged_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::RemoveLinkToBeChallenged>(GetArena());
  }
  return _impl_.payload_.remove_link_to_be_challenged_;
}
inline ::debate_event::RemoveLinkToBeChallenged* DebateEvent::mutable_remove_link_to_be_challenged() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::RemoveLinkToBeChallenged* _msg = _internal_mutable_remove_link_to_be_challenged();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.remove_link_to_be_challenged)
  return _msg;
}

// .debate_event.DeleteChallenge delete_challenge = 48 [json_name = "deleteChallenge"];
inline bool DebateEvent::has_delete_challenge() const {
  return payload_case() == kDeleteChallenge;
}
inline bool DebateEvent::_internal_has_delete_challenge() const {
  return payload_case() == kDeleteChallenge;
}
inline void DebateEvent::set_has_delete_challenge() {
  _impl_._oneof_case_[0] = kDeleteChallenge;
}
inline void DebateEvent::clear_delete_challenge() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (payload_case() == kDeleteChallenge) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.delete_challenge_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.payload_.delete_challenge_);
    }
    clear_has_payload();
  }
}
inline ::debate_event::DeleteChallenge* DebateEvent::release_delete_challenge() {
  // @@protoc_insertion_point(field_release:debate_event.DebateEvent.delete_challenge)
  if (payload_case() == kDeleteChallenge) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_challenge_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.delete_challenge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::debate_event::DeleteChallenge& DebateEvent::_internal_delete_challenge() const {
  return payload_case() == kDeleteChallenge ? *_impl_.payload_.delete_challenge_ : reinterpret_cast<::debate_event::DeleteChallenge&>(::debate_event::_DeleteChallenge_default_instance_);
}
inline const ::debate_event::DeleteChallenge& DebateEvent::delete_challenge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:debate_event.DebateEvent.delete_challenge)
  return _internal_delete_challenge();
}
inline ::debate_event::DeleteChallenge* DebateEvent::unsafe_arena_release_delete_challenge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:debate_event.DebateEvent.delete_challenge)
  if (payload_case() == kDeleteChallenge) {
    clear_has_payload();
    auto* temp = _impl_.payload_.delete_challenge_;
    _impl_.payload_.delete_challenge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DebateEvent::unsafe_arena_set_allocated_delete_challenge(::debate_event::DeleteChallenge* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_delete_challenge();
    _impl_.payload_.delete_challenge_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:debate_event.DebateEvent.delete_challenge)
}
inline ::debate_event::DeleteChallenge* DebateEvent::_internal_mutable_delete_challenge() {
  if (payload_case() != kDeleteChallenge) {
    clear_payload();
    set_has_delete_challenge();
    _impl_.payload_.delete_challenge_ =
        ::google::protobuf::Message::DefaultConstruct<::debate_event::DeleteChallenge>(GetArena());
  }
  return _impl_.payload_.delete_challenge_;
}
inline ::debate_event::DeleteChallenge* DebateEvent::mutable_delete_challenge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::debate_event::DeleteChallenge* _msg = _internal_mutable_delete_challenge();
  // @@protoc_insertion_point(field_mutable:debate_event.DebateEvent.delete_challenge)
  return _msg;
}

inline bool DebateEvent::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void DebateEvent::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline DebateEvent::PayloadCase DebateEvent::payload_case() const {
  return DebateEvent::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace debate_event


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::debate_event::EventType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::debate_event::EventType>() {
  return ::debate_event::EventType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // debate_5fevent_2eproto_2epb_2eh
